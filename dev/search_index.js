var documenterSearchIndex = {"docs":
[{"location":"references/#Useful-References","page":"References","title":"Useful References","text":"","category":"section"},{"location":"references/#Web","page":"References","title":"Web","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"The Actor model on Wikipedia\nHewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know...) on YouTube\nJoe Armstrong: Making reliable distributed systems in the presence of software errors.- 2003, Dissertation\nRobert Virding in this thread on the elixir forum suggests that there are two complementary roads to actors, a theoretical and a pragmatic one.","category":"page"},{"location":"references/#Books","page":"References","title":"Books","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press\nJoe Armstrong: Programming Erlang, 2nd ed., Software for a Concurrent World.- 2013 Pragmatic Programmers\nPaul Butcher: Seven Concurrency Models in Seven Weeks, When Threads Unravel.- 2014 Pragmatic Programmers\nRoland Kuhn: Reactive Design Patterns.- 2017, Manning\nVaughn Vernon: Reactive Messaging Patterns with the Actor Model, Applications and Integrations in Scala and Akka.- 2016, Pearson","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"CurrentModule = YAActL","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"An Actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL actors are Julia Tasks running on a computer or in a network, represented by local or remote Links, channels over which they receive and send messages [2]. They:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"react to those messages,\nexecute a user defined behavior function when they receive certain messages,\nchange their behavior upon request,\nupdate their internal state which influences how they behave.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following provides an overview of YAActL actors:","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In the simplest case we start an Actor with a behavior function:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using YAActL, .Threads\nact1 = Actor(threadid)               # start an actor who gives its threadid\ncall!(act1)                          # call it\nact2 = Actor(parallel(), threadid)   # start a parallel actor\ncall!(act2)                          # and call it\nusing Distributed\naddprocs(1);\n@everywhere using YAActL\nact3 = Actor(2, println)            # start a remote actor on pid 2 with a println behavior\ncall!(act3, \"Tell me where you are!\") # and call it with an argument","category":"page"},{"location":"actors/#Links","page":"Actors","title":"Links","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"When we started our first actor, we got a Link to it. This represents a local Channel over which actors can receive and send messages. Our third actor got a link with a RemoteChannel. Actors are only represented by their links.","category":"page"},{"location":"actors/#Messages","page":"Actors","title":"Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL actors communicate and act asynchronously on messages. Basically they use only two functions to interact:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!: send a message to an actor,\nreceive!: receive a message from an actor.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"They operate on internal messages, all of type Message, used by the API functions described below.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"A user can also implement his own message types and dispatch the actor behavior based on them. For example a user may implement:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"struct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Then he can write a function dispatching on them, start an actor with this behavior and send it Pop or Push messages.","category":"page"},{"location":"actors/#Behavior","page":"Actors","title":"Behavior","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"When actors receive","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"arguments from cast! or call! or\na Request or a user implemented message","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"they compose their owned arguments with the received ones and dispatch their behavior function. Then they store the return value in their internal res variable.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Following further our example:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> mystack = Actor(stack_node, StackNode(nothing, Link())); # start an actor with a first argument","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack represents an actor with a stack_node behavior and first argument StackNode(nothing, Link()). When it eventually receives a message ...","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"julia> send!(mystack, Push(1))        # push 1 on the stack","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"..., it executes stack_node(StackNode(nothing, Link()), Push(1)).","category":"page"},{"location":"actors/#Actor-Control","page":"Actors","title":"Actor Control","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!: cause an actor to switch its behavior,\ncast!: cause an actor to execute its behavior function,\nexit!: cause an actor to terminate,\ninit!: tell an actor to execute a function at startup,\nset!: set an actor's dispatch mode,\nterm!: tell an actor to execute a function when it terminates,\nupdate!: update an actor's internal state.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those functions are wrappers to internal messages and to send!.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can also operate on themselves, or rather they send messages to themselves:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become: an actor switches its own behavior,\nself: an actor gets a link to itself,\nstop: an actor stops.","category":"page"},{"location":"actors/#Bidirectional-Messages","page":"Actors","title":"Bidirectional Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"What if you want to receive a reply from an actor? Then there are two possibilities:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send! a message to an actor and then receive! the Response asynchronously,\nrequest!: send a message to an actor, block and receive the result synchronously.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following functions do this for specific duties:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"call! an actor to execute its behavior function and to send the result,\nexec!: tell an actor to execute a function and to send the result,\nquery! tell an actor's to send one of its internal state variables.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"If you provide those functions with a return link, they will use send! and you can then receive! the Response from the return link. If you  don't provide a return link, they will use request! to block and return the result. Note that you should not use blocking when you need to be strictly responsive.","category":"page"},{"location":"actors/#Using-the-API","page":"Actors","title":"Using the API","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The API functions allow to work with actors without using messages explicitly:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using YAActL, .Threads # hide\nact4 = Actor(parallel(), +, 4) # start an actor adding to 4\nexec!(act4, Func(threadid))    # ask it its threadid\ncast!(act4, 4)                 # cast it 4\nquery!(act4, :res)             # query the result\nbecome!(act4, *, 4);           # switch the behavior to *\ncall!(act4, 4)                 # call it with 4\nexec!(act4, Func(broadcast, cos, pi .* (-2:2))) # tell it to exec any function\nexit!(act4)                    # stop it\nact4.state","category":"page"},{"location":"actors/#Actor-Registry","page":"Actors","title":"Actor Registry","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"If a parent actor or worker process creates a new actor, the link to it is only locally known. It has to be sent to all other actors that want to communicate with it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Alternatively an actor link can be registered under a name (a Symbol). Then any actor in the system can communicate with it using that name.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"using YAActL, Distributed\naddprocs(1);\n@everywhere using YAActL\n@everywhere function ident(id, from)\n    id == from ?\n        (\"local actor\",  id, from) :\n        (\"remote actor\", id, from)\nend\nsleep(1) # hide\nregister(:act1, Actor(ident, 1))       # a registered local actor\ncall!(:act1, myid())                   # call! it\nregister(:act2, Actor(2, ident, 2))    # a registered remote actor on pid 2\ncall!(:act2, myid())                   # call! it\nfetch(@spawnat 2 call!(:act1, myid())) # call! :act1 on pid 2\nfetch(@spawnat 2 call!(:act2, myid())) # call! :act2 on pid 2\nwhereis(:act1)                         # get a link to :act1\nwhereis(:act2)                         # get a link to :act2\nfetch(@spawnat 2 whereis(:act1))       # get a link to :act1 on pid 2\nregistered()                           # get a list of registered actors\nfetch(@spawnat 2 registered())         # get it on pid 2","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The registry works transparently across workers. All workers have access to registered actors on other workers via remote links.","category":"page"},{"location":"actors/#Actor-Isolation","page":"Actors","title":"Actor Isolation","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In order to avoid race conditions actors have to be strongly isolated from each other:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"they do not share state,\nthey must not share mutable variables.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"An actor stores the behavior function and arguments to it, results of computations and more. Thus it has state and this influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"But it does not share its state variables with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state via messaging.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Mutable variables in Julia can be sent over local channels without being copied. Accessing those variables from multiple threads can cause race conditions. The programmer has to be careful to avoid those situations either by","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"not sharing them between actors,\ncopying them when sending them to actors or\nacquiring a lock around any access to data that can be observed from multiple threads. [3]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"When sending mutable variables over remote links, they are automatically copied.","category":"page"},{"location":"actors/#Actor-Local-Dictionary","page":"Actors","title":"Actor Local Dictionary","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Since actors are Julia tasks, they have a local dictionary in which you can store values. You can use task_local_storage to access it in behavior functions. But normally the state variable sta and argument passing should be enough to handle values in actors.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: They build on Julia's concurrency primitives  @spawn, put! and take! on Channels.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[3]: see Data race freedom in the Julia manual.","category":"page"},{"location":"examples/factorial/#factorial_example","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"","category":"section"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"note: This illustrates the actor model\nIt is not a proposal for an actual factorial implementation. It uses YAActLs message API to be as close as possible to Agha's orginal example.","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"This is Agha's example 3.2.2:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Our implementation of the factorial relies on creating a customer which waits for the appropriate communication, in this case from the factorial actor itself. The factorial actor is free to concurrently process the next communication. We assume that a communication to a factorial includes a mail address to which the value of the factorial is to be sent.","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"For a requested factorial x  x  0 the factorial actor creates a customer actor on a parallel thread answering the request and sends itself a request with x-1 from the newly created customer. The created chain of customer actors finally answers the original request. We implement first the behaviors and then setup the factorial actor F and a response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"using YAActL\n\nfunction rec_factorial(f::Request)\n    if f.x == 0\n        send!(f.u, Response(1))\n    else\n        c = Actor(parallel(), rec_customer, f.x, f.u) # setup parallel actors\n        send!(self(), Request(f.x - 1, c))\n    end\nend\n\nfunction rec_customer(n::Integer, u::Link, k::Response) \n    send!(u, Response(n * k.y))\n    stop()\nend\n\nF = Actor(rec_factorial)\nresp = newLink()","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Now we can send requests to the factorial actor and take the answers from the response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"julia>  for i ∈ 0:5:50      # send and receive loop\n            send!(F, Request(big(i), resp))\n            println(receive!(resp).y)\n        end\n1\n120\n3628800\n1307674368000\n2432902008176640000\n15511210043330985984000000\n265252859812191058636308480000000\n10333147966386144929666651337523200000000\n815915283247897734345611269596115894272000000000\n119622220865480194561963161495657715064383733760000000000\n30414093201713378043612608166064768844377641568960512000000000000","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"If we send our requests successively without waiting and then read the response link, we still get the same sequence – which is a bit surprising. ","category":"page"},{"location":"behavior/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = YAActL","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior is a ...","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"As an example we define two behaviors forward! and stack_node, the latter with two methods, dispatched on the user implemented messages Push and Pop.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Like any Julia function a behavior function can be implemented with different methods. The methods are dispatched ...","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"based on the number of arguments given, and on the types of all of the function's arguments [2].","category":"page"},{"location":"behavior/#dispatch","page":"Behaviors","title":"Behavior Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In the above example stack_node has two arguments: sn and msg. The first represents state, the second represents an event. An event happens when a message arrives. The actor already has the state argument and gets the event argument with the message.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"With its creation as Actor(stack_node, sn) the actor gets the first argument sn.\nWith a message msg it gets the second argument and calls stack_node(sn, msg).\nDepending on whether the incoming message is a Pop or a Push one of the two implemented methods is dispatched.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"YAActL allows to send arguments to actors:","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"With cast! or call! you can send them any arguments.\nOr you can send! them a Request or a user implemented message.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Then an actor combines its first arguments with the received second arguments and executes the behavior function.","category":"page"},{"location":"behavior/#composition","page":"Behaviors","title":"Argument Composition","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"You can set! YAActL actors into","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"full dispatch or\nstate dispatch.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The Dispatch mode determines how actors compose arguments and whether they use the returned value of the behavior function to update their internal state.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"using YAActL # hide\nmult2 = Actor(*, 2);  # create a new actor to multiply by 2 in full dispatch\n[call!(mult2, i) for i in 1:10]\nset!(mult2, state);   # set it to state dispatch\nupdate!(mult2, 2);    # set its state to 2\n[call!(mult2, i) for i in 1:10]\nquery!(mult2)         # query its state\nset!(mult2, full);    # back to full dispatch\ncall!(mult2, 10)      # again it multiplies by 2","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The two dispatch modes cause quite different behaviors.","category":"page"},{"location":"behavior/#Full-Dispatch","page":"Behaviors","title":"Full Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"With Actor(stack_node, sn) we used full dispatch. The actor got sn as the first argument and can use that to represent state. If it is mutable, the behavior function can change its content. When a message msg arrives, the actor takes it as the second argument and composes them to execute the behavior.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"To install a behavior function bhv and its first arguments args1... we have","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"act = Actor(bhv, args1...) or\nbecome!(act, bhv, args1...).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The second arguments args2... get delivered with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"call!(act, args2...) or\ncast!(act, args2...) or\nsend!(act, msg).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The actor then calls","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"bhv((args1..., args2...)...) or\nbhv((args1..., msg)...) respectively.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Empty arguments for args1... or args2... are allowed as long as their composition can be used to dispatch the behavior function bhv.","category":"page"},{"location":"behavior/#State-Dispatch","page":"Behaviors","title":"State Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In state dispatch an actor uses its internal state sta as first argument to the behavior function. On a message msg it calls the behavior as bhv(sta, msg) and saves the returned value back to its internal state variable sta. Thus it operates as a finite-state machine.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"A behavior bhv is installed without arguments[3] as","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"act = Actor(bhv) or\nbecome!(act, bhv).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Actor state sta can be set ","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"with update!(act, args1...) or\nby an init function installed with init!.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The second arguments args2... get delivered with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"call!(act, args2...) or\ncast!(act, args2...) or\nsend!(act, msg).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"and the actor calls","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"bhv((sta, args2...)...) or\nbhv((sta, msg)...) respectively","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"and updates sta with the returned value y. At the next call the behavior bhv gets dispatched with the updated status and the new message.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"note: Status is updated if behavior returns something.\nThe actor updates sta only if its behavior function returns something. If you want your behavior to not update sta, let it return nothing. ","category":"page"},{"location":"behavior/#Keyword-Arguments","page":"Behaviors","title":"Keyword Arguments","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In both modes an actor passes keyword arguments kwargs... to the behavior function. Those are not dispatched on but they too represent state and therefore can change the function result.","category":"page"},{"location":"behavior/#Control-of-Actor-Behavior","page":"Behaviors","title":"Control of Actor Behavior","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The described mechanisms allow a fine-grained control of an actor's behavior:","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Set an actor's behavior function at startup or with become!.\nControl the dynamic dispatch of implemented behavior methods with\nthe actor's dispatch mode,\nthe first arguments  \neither of the behavior function in full dispatch,\nor the actor state sta in state dispatch,\nthe second arguments from the incoming message.\nControl the result of the dispatched function or method by setting the values of arguments and keyword arguments[4].","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"This allows actors to use Julia's full expressiveness with functions and methods.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[2]: from Methods in the Julia manual.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[3]: arguments arg1... to the behavior function are simply ignored in state dispatch.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[4]: you can also dispatch on values by using Val","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = YAActL","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages to YAActL actors have Message as a common abstract type. Only three predefined messages are exported:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Response: response message type from actor to any synchronous message (requiring a response),\nRequest: predefined message type for implementing requests to actors.\nTimeout: answer of receive! when a timeout occurs.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages other than the predefined ones can be implemented by a user.","category":"page"},{"location":"messages/#Functions-and-Arguments","page":"Messages","title":"Functions and Arguments","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are two types needed for transmitting functions and function arguments to actors with messages:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Func\nArgs","category":"page"},{"location":"messages/#YAActL.Func","page":"Messages","title":"YAActL.Func","text":"Func(f, args...; kwargs...)\n\nA structure for passing a function f and its arguments to an actor.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Args","page":"Messages","title":"YAActL.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors recognize and react to the following predefined internal messages:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nDiag\nExec\nInit\nQuery\nStop\nTerm\nUpdate","category":"page"},{"location":"messages/#YAActL.Become","page":"Messages","title":"YAActL.Become","text":"Become(x::Func)\n\nAn asynchronous Message to an actor to change its  behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Call","page":"Messages","title":"YAActL.Call","text":"Call(arg, from::Link)\n\nA synchronous Message to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Cast","page":"Messages","title":"YAActL.Cast","text":"Cast(arg)\n\nAn asynchronous Message to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Diag","page":"Messages","title":"YAActL.Diag","text":"Diag(from::Link)\n\nA synchronous Message to an actor to send a  Response message with its internal _ACT variable to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Exec","page":"Messages","title":"YAActL.Exec","text":"Exec(func::Func, from::Link)\n\nA synchronous Message to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Init","page":"Messages","title":"YAActL.Init","text":"Init(f::Func)\n\nA Message to an actor to execute the given Func and to register it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Query","page":"Messages","title":"YAActL.Query","text":"Query(s::Symbol, from::Link)\n\nA Message to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Stop","page":"Messages","title":"YAActL.Stop","text":"Stop(code=0)\n\nA Message causing an actor to stop with an exit code. If present, it calls its term! function with code as last argument.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Term","page":"Messages","title":"YAActL.Term","text":"Term(x::Func)\n\nA Message to an actor to save the given Func  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Update","page":"Messages","title":"YAActL.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Message to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :sta, :dsp, :arg, :lnk.\n\n\n\n\n\n","category":"type"},{"location":"messages/","page":"Messages","title":"Messages","text":"Those messages are interfaced by the functions in the YAActL API.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"If an actor receives another subtype of Message, it calls its behavior function with it as last argument.","category":"page"},{"location":"_index/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"_index/","page":"Index","title":"Index","text":"Modules = [YAActL]\nOrder   = [:module, :constant]","category":"page"},{"location":"_index/#Types","page":"Index","title":"Types","text":"","category":"section"},{"location":"_index/","page":"Index","title":"Index","text":"Modules = [YAActL]\nOrder   = [:type]","category":"page"},{"location":"_index/#Functions-and-Macros","page":"Index","title":"Functions and Macros","text":"","category":"section"},{"location":"_index/","page":"Index","title":"Index","text":"Modules = [YAActL]\nOrder   = [:function, :macro]","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A YAActL actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"is a task running on a thread or a remote node which\nreceives messages over a channel and with it\ndispatches a behavior function or one of of its methods.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using YAActL, Printf\n\n# define two functions for printing a message\nfunction pr(msg)\n    print(@sprintf(\"%s\\n\", msg))\n    become(pr, \"Next\") # change behavior\nend\npr(info, msg) = print(@sprintf(\"%s: %s\\n\", info, msg))\n\n# a function for doing arithmetic\ncalc(op::F, x, y) where F<:Function = op(x, y)\n\n# start an actor with the first behavior\nmyactor = Actor(pr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now we can interact with it:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"My first actor\")     # send a message to it\nMy first actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor has executed its behavior function pr with the message as argument. You may have noticed above that pr(msg) causes the actor to change its behavior to pr(\"Next:\", msg). Now we send it something else:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"Something else\")     # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\") # change the behavior to another one\n\njulia> cast!(myactor, \"bla bla bla\")        # and send again a message\nNew behavior: bla bla bla","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor can also change to a completely different behavior and do some arithmetic:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> become!(myactor, calc, +, 10);       # now become a machine for adding to 10\n\njulia> call!(myactor, 5)                    # send a request to add 5 to it and to return the result\n15\n\njulia> become!(myactor, ^);                 # become an exponentiation machine\n\njulia> call!(myactor, 123, 456)             # try it\n2409344748064316129","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Actors thus can represent different and changing behaviors of real world or computational objects.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If we implement and start multiple actors interacting with each other, we get an actor system.","category":"page"},{"location":"examples/stack/#stack_example","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"","category":"section"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"note: This illustrates the actor model\nIt is not a proposal for an actual stack implementation. It uses YAActLs message API to be as close as possible to Agha's orginal example.","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"This is Agha's example 3.2.1. It implements a stack of actors with two operations/messages Push and Pop. A StackNode stores a content and a Link to the next Actor in the chain.","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can affect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element.","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"We define types for stack nodes and messages. We want our stack actor to dispatch its behavior on push and pop.","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"using YAActL\n\nmutable struct StackNode{T}\n    content::T\n    link::Link\nend\n\n# define the messages\nstruct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"The code implementing the actor's behavior is very similar to Agha's example:","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"Then we create the top of the stack (the receptionist). All other actors of the system are created internally each time we send a Push message. We interact only with the top of the stack:","category":"page"},{"location":"examples/stack/","page":"A Linked List of Actors","title":"A Linked List of Actors","text":"julia> mystack = Actor(stack_node, StackNode(nothing, Link()))\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> response = newLink()           # create a response link\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> send!(mystack, Push(1))        # push 1 on the stack\nPush{Int64}(1)\n\njulia> send!(mystack, Pop(response))  # pop it\nPop(Channel{Message}(sz_max:32,sz_curr:1))\n\njulia> receive!(response).y           # returns 1, 1st node now forwards messages\n1\n\njulia> send!(mystack, Pop(response)); # pop again\n\njulia> receive!(response)             # now nothing is left\n\njulia> for i ∈ 1:5\n           send!(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send!(mystack, Pop(response))\n           println(receive!(response).y)\n       end\n5\n4\n3\n2\n1","category":"page"},{"location":"diagnosis/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"CurrentModule = YAActL","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. You can register! an actor channel to a Vector{Link} in order to get access to the tasks.","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"register!\nistaskfailed(::Link)\nistaskfailed(::Vector{Link})\ninfo","category":"page"},{"location":"diagnosis/#YAActL.register!","page":"Diagnosis","title":"YAActL.register!","text":"register!(lks::Vector{Link}, lk::Link)\n\nRegister a link lk to a vector of links lks.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Link}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Array{Link,1}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lks::Vector{Link})\n\nReturns true if any task associated with a vector lks of links has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#YAActL.info","page":"Diagnosis","title":"YAActL.info","text":"info(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"For diagnostic purposes it is possible to get access to the actor's ACT variable:","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"diag!","category":"page"},{"location":"diagnosis/#YAActL.diag!","page":"Diagnosis","title":"YAActL.diag!","text":"diag!(lk::Link)\ndiag!(name::Symbol)\n\nReturn the internal _ACT variable of the lk actor. This is only for diagnosis and testing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#state","page":"Actor State","title":"Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"CurrentModule = YAActL","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"YAActL follows Julia's philosophy in giving the user responsibility for access to internals and implementing correct programs:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"You are entirely responsible for ensuring that your program is data-race free, and nothing promised here can be assumed if you do not observe that requirement. The observed results may be highly unintuitive. [1]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"When using multi-threading we have to be careful when using functions that are not pure as we might get a wrong answer. [2]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Since concurrency is the overarching theme of actor programming, and behavior functions must access data to do their job, data-race freedom is a major concern in working with actors. As a ground rule actors don't share state and mutable variables.","category":"page"},{"location":"internals/#Internal-State","page":"Actor State","title":"Internal State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Actors have an internal mutable state variable: ","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"_ACT","category":"page"},{"location":"internals/#YAActL._ACT","page":"Actor State","title":"YAActL._ACT","text":"_ACT()\n\nInternal actor status variable.\n\nFields\n\ndsp::Dispatch: dispatch mode,\nsta::Tuple: the actor's status variable,\nres::Tuple: the result of the last behavior execution,\nbhv::Func : the behavior function and its internal arguments,\ninit::Func: the init function and its arguments,\nterm::Func: the terminate function and its arguments,\nself::Link: the actor's (local or remote) self,\nname::Symbol: the actor's registered name.\n\nsee also: Dispatch, Func, Link\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Functions executed by an actor can access their actor's internal ACT variable via task_local_storage(\"ACT\").  Normally this is not needed.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"We must express two important concerns regarding actor state:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"note: Actor state is multifaceted!\nActor state is not a single value but includes behavior functions, arguments and an explicit mutable state variable, which is used for state Dispatch or for representing agents.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"warning: Sharing state can cause critical race conditions!\nYou must be careful not to share any of the state variables between actors in order to avoid critical race conditions.","category":"page"},{"location":"internals/#Create-Private-Actor-State","page":"Actor State","title":"Create Private Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"The returned value of the init! function is saved as an actors state sta. It is a good practice to have an init function to create a private actor state with defined initial parameters.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Be careful to update! the actor's state since this overwrites it. Don't update it with a shared variable!","category":"page"},{"location":"internals/#Update-Actor-State","page":"Actor State","title":"Update Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Only the actor itself is allowed to update its state in a strictly sequential manner by processing message after message.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Other actors or users can cause an actor to update its state by sending it a message, which is done implicitly by using the API function update!.","category":"page"},{"location":"internals/#Behavior-Function-Arguments","page":"Actor State","title":"Behavior Function Arguments","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Julia functions accept mutable types as parameters and can change their values. YAActL messages and API functions allow to send mutable variables. ","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"If your behavior functions get mutable types as parameters, you must ensure that","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"either you don't share those variables between actors\nor you don't change them by using only pure functions as behaviors.","category":"page"},{"location":"internals/#Mutable-Variables","page":"Actor State","title":"Mutable Variables","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"warning: Sharing mutable variables is dangerous!\nRace conditions can happen if actors in parallel use or modify global or shared variables. The best advice is not to use global or shared variables with actors.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"If for some reason you want to use global variables or to share variables between actors, you must use a lock or atomic operations described in the Julia manual. But both approaches block an actor until it succeeds to access the variable.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[1]: see: Data-race freedom in the Julia manual.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[2]: see: Side effects and mutable function arguments in the Julia manual.","category":"page"},{"location":"api/#Actor-API","page":"Actor API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"CurrentModule = YAActL","category":"page"},{"location":"api/#Installation","page":"Actor API","title":"Installation","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"YAActL\nYAActL.version","category":"page"},{"location":"api/#YAActL.YAActL","page":"Actor API","title":"YAActL.YAActL","text":"YAActL\n\nYet Another Actor Library (in Julia VERSION ≥ v\"1.3\").\n\nThe current stable, registered version is installed with\n\npkg> add YAActL\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/YAActL.jl\")\n\n\n\n\n\n","category":"module"},{"location":"api/#YAActL.version","page":"Actor API","title":"YAActL.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"using YAActL\nYAActL.version","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions provide a user interface to actors:","category":"page"},{"location":"api/#Start","page":"Actor API","title":"Start","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actor","category":"page"},{"location":"api/#YAActL.Actor","page":"Actor API","title":"YAActL.Actor","text":"Actor([lp::LinkParams], bhv::Function, args1...; kwargs...)\nActor(pid::Int, bhv::Function, args1...; kwargs...)\n\nCreate a new actor. Start a task listening to messages msg  sent over the returned self and executing bhv(args1..., msg; kwargs...)  for each message. The actor stops if sent Stop().\n\nArguments\n\n[lp::LinkParams]: parameters for creating the actor,\npid::Int: process pid to create the actor on, this can    also be given with lp,\nbhv: a function implementing the actor's behavior,\nargs1...: first arguments to bhv (without possible msg arguments),\nkwargs...: keyword arguments to bhv.\n\nReturns\n\na Link to a created actor.\n\nsee also: LinkParams\n\nExample\n\njulia> using YAActL, .Threads\n\njulia> act1 = Actor(threadid)               # start an actor who gives its threadid\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> call!(act1)                          # call it\n1\n\n\n\n\n\n","category":"function"},{"location":"api/#links","page":"Actor API","title":"Links","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"An actor is only represented by its link which it returns upon creation:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Link\nislocal","category":"page"},{"location":"api/#YAActL.Link","page":"Actor API","title":"YAActL.Link","text":"Link{C}(chn::C, pid::Int, type::Symbol)\n\nA mailbox for communicating with actors.\n\nFields/Parameters\n\nchn::C: \npid::Int: \ntype::Symbol: \n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.islocal","page":"Actor API","title":"YAActL.islocal","text":"islocal(lk::Link)\nislocal(name::Symbol)\n\nReturns true if the actor lk or name has the same pid as the caller, else false.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors correspond with other actors over links. There is a default link for users to communicate with actors.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"USR","category":"page"},{"location":"api/#YAActL.USR","page":"Actor API","title":"YAActL.USR","text":"User remote channel for interacting with actors.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"For setting up links explicitly we have the following functions.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"LinkParams\nparallel","category":"page"},{"location":"api/#YAActL.LinkParams","page":"Actor API","title":"YAActL.LinkParams","text":"LinkParams(pid=myid(), size=32; taskref=nothing, spawn=false)\n\nParameters for setting up an Actor. \n\npid::Int: process identification,\nsize::Int: channel buffer size, must be size ≥ 10,\ntaskref::Union{Nothing, Ref{Task}}: If you need a reference to the created task,   pass a Ref{Task} object via the keyword argument taskref.\nspawn::Bool: If spawn = true, the Task created may be scheduled on another   thread in parallel, equivalent to creating a task via Threads.@spawn.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.parallel","page":"Actor API","title":"YAActL.parallel","text":"parallel(size=32; taskref=nothing)\n\nReturn LinkParams with spawn=true.\n\nExample\n\njulia> using YAActL, .Threads\n\njulia> myactor = Actor(parallel(), threadid);\n\njulia> call!(myactor)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors can send! and receive! messages over links.","category":"page"},{"location":"api/#Messages","page":"Actor API","title":"Messages","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Messages in YAActL have a common abstract type. Only a few predefined messages are exported:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Message\nResponse\nRequest\nTimeout","category":"page"},{"location":"api/#YAActL.Message","page":"Actor API","title":"YAActL.Message","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Response","page":"Actor API","title":"YAActL.Response","text":"Response(y, from::Link=self())\n\nA Message representing a response to requests.\n\nFields\n\ny: response content,\nfrom::Link: sender link.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Request","page":"Actor API","title":"YAActL.Request","text":"Request(x, from::Link)\n\nA generic Message for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Timeout","page":"Actor API","title":"YAActL.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors operate with internal messages. Further messages can be implemented by a user. If an actor receives a Request or a user implemented message, it passes it as last argument to the behavior function.","category":"page"},{"location":"api/#Send-and-Receive","page":"Actor API","title":"Send and Receive","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Messages are sent and received using the following basic functions:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"send!\nreceive!","category":"page"},{"location":"api/#YAActL.send!","page":"Actor API","title":"YAActL.send!","text":"send!(lk::Link, m::Message)\nsend!(name::Symbol, m::Message)\n\nSend a message m to an actor lk or name (if registered).\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.receive!","page":"Actor API","title":"YAActL.receive!","text":"receive!(lk; timeout=5.0)\nreceive!(lk, from; timeout=5.0)\nreceive!(lk, Msg; timeout=5.0)\nreceive!(lk, Msg, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf Msg or from are provided, receive! returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::Link: local or remote link over which the message is received,\nMsg::Type{<:Message}: Message type,\nfrom::Link: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"julia> myactor = Actor(parallel(), threadid);\n\njulia> send!(myactor, YAActL.Call(USR)); # the same as call!(myactor, USR)\n\njulia> receive!(USR).y                   # receive the result\n2\n\njulia> receive!(USR)                     # gives after some seconds ...\nTimeout()","category":"page"},{"location":"api/#Dispatch-mode","page":"Actor API","title":"Dispatch mode","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors have a dispatch mode:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Dispatch","category":"page"},{"location":"api/#YAActL.Dispatch","page":"Actor API","title":"YAActL.Dispatch","text":"Dispatch\n\nDepending on its Dispatch mode an actor composes the arguments  to the behavior function:\n\nfull: from the Become args... and the msg.x....   This is the default dispatch mode.\nstate: from the actor state and the msg.x.... In this case the    actor updates its state with the result of the behavior   function. The result is saved in a Tuple. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Actor API","title":"Actor API","text":"julia> set!(myactor, state)              # set state dispatch\nYAActL.Update{Dispatch}(:dsp, state)\n\njulia> set!(myactor, full)               # set full dispatch\nYAActL.Update{Dispatch}(:dsp, full)","category":"page"},{"location":"api/#Actor-Control","page":"Actor API","title":"Actor Control","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions control actor behavior and state by sending implicit messages. Actors don't send a Response to those.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"become!\ncast!\nexit!\nset!\nupdate!","category":"page"},{"location":"api/#YAActL.become!","page":"Actor API","title":"YAActL.become!","text":"become!(lk::Link, bhv::Function, args1...; kwargs...)\nbecome!(name::Symbol, ....)\n\nCause an actor to change behavior.\n\nArguments\n\nactor lk::Link (or name::Symbol if registered),\nbhv: function implementing the new behavior,\nargs1...: first arguments to bhv (without a possible msg argument),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.cast!","page":"Actor API","title":"YAActL.cast!","text":"cast!(lk::Link, args2...)\ncast!(name::Symbol, args2...)\n\nCast a message to the actor lk (or name if registered) to  execute its behavior with args2... without sending a  response. \n\nNote: you can prompt the returned value with query!.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.exit!","page":"Actor API","title":"YAActL.exit!","text":"exit!(lk::Link, code=0)\nexit!(name::Symbol, code=0)\n\nTell an actor lk (or name if registered) to exit. If it has a term  function, it calls it with code as last argument. \n\nnote: This behavior is not yet fully implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.set!","page":"Actor API","title":"YAActL.set!","text":"set!(lk::Link, dsp::Dispatch)\nset!(name::Symbol, dsp::Dispatch)\n\nSet the lk actor's Dispatch to dsp.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.update!","page":"Actor API","title":"YAActL.update!","text":"update!(lk::Link, x; s::Symbol=:sta)\nupdate!(lk::Link, arg::Args)\nupdate!(name::Symbol, ....)\n\nUpdate an actor's internal state s with args....\n\nArguments\n\nan actor lk::Link or name::Symbol (if registered),\nx: value/variable to update the choosen state with,\narg::Args: arguments to update,\ns::Symbol: can be one of :sta, :dsp, :arg, :self, :name.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  to arg. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExample\n\njulia> update!(fact, 5)       # note that fact is in state dispatch\nYAActL.Update{Int64}(:sta, 5)\n\njulia> call!(fact, 5)         # call it with 5\n10\n\njulia> update!(fact, Args(0, u=5));  # update arguments\n\njulia> call!(fact, 5)         # add the last result, 5 and u=5\n20\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"If a behavior function wants to control its own actor, it can use the following functions:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"become\nself\nstop","category":"page"},{"location":"api/#YAActL.become","page":"Actor API","title":"YAActL.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.self","page":"Actor API","title":"YAActL.self","text":"self()\n\nGet the Link of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.stop","page":"Actor API","title":"YAActL.stop","text":"stop(code=0)\n\nCause your actor to exit with code.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bidirectional-Messaging","page":"Actor API","title":"Bidirectional Messaging","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Some messages to actors cause them to send a Response [1]. The exchange of messages may be carried out asynchronously, or may use a synchronous \"rendezvous\" style in which the sender blocks until the message is received.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"YAActL has a primitive for synchronous communication:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"request!","category":"page"},{"location":"api/#YAActL.request!","page":"Actor API","title":"YAActL.request!","text":"request!(lk::Link, msg::Message; full=false, timeout::Real=5.0)\nrequest!(lk::Link, Msg::Type{<:Message}, args...; kwargs...)\nrequest!(name::Symbol, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::Link: actor link, or name::Symbol (if registered),\nmsg::Message: a message,\nMsg::Type{<:Message}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions support both messaging styles:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Send a message with an explicit from-link to an actor and it will respond to this link. Then you can  asynchronously receive! the response from it.\nSend a message with an implicit link to an actor, block, wait for the response and return it.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"call!\nexec!\nquery!","category":"page"},{"location":"api/#YAActL.call!","page":"Actor API","title":"YAActL.call!","text":"call!(lk::Link, from::Link, args2...)\ncall!(lk::Link, args2...; timeout::Real=5.0)\ncall!(name::Symbol, ....)\n\nCall an actor to execute its behavior and to send a  Response with the result. \n\nArguments\n\nactor lk::Link (or name::Symbol if registered), \nfrom::Link: sender link; If from is omitted, call!    blocks and returns the result. \nargs2...: second arguments to the actor.\ntimeout::Real=5.0: timeout in seconds.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.exec!","page":"Actor API","title":"YAActL.exec!","text":"exec!(lk::Link, from::Link, f::Function, args...; kwargs...)\nexec!(lk::Link, from::Link, fu::Func)\nexec!(lk::Link, fu::Func; timeout::Real=5.0)\nexec!(name::Symbol, ....)\n\nAsk an actor lk (or name if registered) to execute an  arbitrary function and to send the returned value as  Response.\n\nArguments\n\nlk::Link or name::Symbol of the actor,\nfrom::Link: the link a Response should be sent to.   If from is ommitted, exec! blocks, waits and returns    the result. In that case there is a timeout.\nf::Function, args...; kwargs... or\nfu::Func: function arguments,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want a timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.query!","page":"Actor API","title":"YAActL.query!","text":"query!(lk::Link, from::Link, s::Symbol)\nquery!(lk::Link, s::Symbol; timeout::Real=5.0)\nquery!(name::Symbol, ....)\n\nAsk the lk actor to send a Response message to from with an internal state variable s. \n\nIf from is omitted, query! blocks and returns the response. In that case there is a timeout.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\nExamples\n\njulia> f(x, y; u=0, v=0) = x+y+u+v  # implement a behavior\nf (generic function with 1 method)\n\njulia> fact = Actor(f, 1)     # start an actor with it\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> cast!(fact, 1)         # cast a second parameter to it\nYAActL.Cast{Tuple{Int64}}((1,))\n\njulia> query!(fact, :res)     # query the result\n2\n\njulia> query!(fact, :bhv)     # query the behavior\nf (generic function with 1 method)\n\njulia> set!(fact, state)      # set dispatch mode\nYAActL.Update{Dispatch}(:dsp, state)\n\njulia> query!(fact, :dsp)     # query the dispatch mode\nstate::Dispatch = 1\n\njulia> update!(fact, 10)      # update the state\nYAActL.Update{Int64}(:sta, 10)\n\njulia> query!(fact)           # query the state variable\n10\n\njulia> call!(fact, 1)\n11\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Registry","page":"Actor API","title":"Actor Registry","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors can be registered with Symbols to a registry. API functions on actors can then be called with their registered names.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"register\nunregister\nwhereis\nregistered","category":"page"},{"location":"api/#YAActL.register","page":"Actor API","title":"YAActL.register","text":"register(name::Symbol, lk::Link)\n\nRegister the actor lk with name. Returns true if the  registration succeeds, false if name is already in use.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.unregister","page":"Actor API","title":"YAActL.unregister","text":"unregister(name::Symbol)\n\nRemove any registrations associated with name.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.whereis","page":"Actor API","title":"YAActL.whereis","text":"whereis(name::Symbol)\n\nFind out whether name is registered. Return the actor link  lk or missing if not found.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.registered","page":"Actor API","title":"YAActL.registered","text":"registered()\n\nReturn an Array of all registered actors in the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The registry works transparently over distributed worker processes such that local links are transformed to remote links when shared between workers.","category":"page"},{"location":"api/#Actor-Supervision","page":"Actor API","title":"Actor Supervision","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"This is not yet implemented.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"init!\nterm!","category":"page"},{"location":"api/#YAActL.init!","page":"Actor API","title":"YAActL.init!","text":"init!(lk::Link, f::Function, args...; kwargs...)\ninit!(name::Symbol, ....)\n\nTell an actor lk to save the function f with the given  arguments as an init function, to execute it  and to save the returned value as state sta  variable.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.term!","page":"Actor API","title":"YAActL.term!","text":"term!(lk::Link, f::Function, args1...; kwargs...)\nterm!(name::Symbol, ....)\n\nTell an actor lk to execute a function f with the given arguments when it terminates. f must accept a code=0  as last argument. This is added by the actor to args1...  when it exit!s.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"[1]: bidirectional messages are Call, Get, Exec and Query.","category":"page"},{"location":"examples/state-machines/#State-Machines","page":"State Machines","title":"State Machines","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"There are various ways to implement state machines with actors. The following examples illustrate how actors operate as state machines and are not to propose actual implementations.","category":"page"},{"location":"examples/state-machines/#DFAs,-behavior-switch","page":"State Machines","title":"DFAs, behavior-switch","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Behavior-switch is the most elegant way to implement a finite state machine with an actor.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Take a deterministic finite automaton with four states sqpr, three inputs abc and the transition function δ represented in a table:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"  a b c\ninitial state -> s s q s\n p p q p\n q p r r\naccepting state * r r r r","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"The state-transition table can be implemented directly:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"using YAActL\n\ns(::Val{'b'}) = become(q)  # implement behaviors\ns(x) = nothing             # default transition\np(::Val{'b'}) = become(q)\np(x) = nothing\nq(::Val{'a'}) = become(p)\nq(::Val{'b'}) = become(r)\nq(::Val{'c'}) = become(r)\nq(x) = nothing\nr(x) = nothing","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"DFA-states are directly represented by behavior functions. Those switch behavior/state on certain input values or otherwise do nothing.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"The actor ist started with the initial behavior. A check function parses input strings:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"mydfa = Actor(s)\n\nfunction check(lk::Link, str::String)\n    become!(lk, s)         # switch to initial state\n    foreach(str) do c\n        cast!(lk, Val(c))  # send all chars to the actor\n    end\n    query!(lk, :bhv) == r  # check the final state\nend","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"It checks which strings get accepted:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"julia> check(mydfa, \"baab\")\nfalse\n\njulia> check(mydfa, \"baabc\")\ntrue\n\njulia> check(mydfa, \"babaccabb\")\ntrue","category":"page"},{"location":"examples/state-machines/#NFAs,-state-dispatch","page":"State Machines","title":"NFAs, state-dispatch","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Non-deterministic finite automata can have more complex states, and more than one transition can happen at an input event.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"  a b c\ninitial state -> s {t,v,w} ∅ ∅\n t {u,v} {u,v} ∅\naccepting state * u {s,w} {s,w} ∅\naccepting state * v ∅ {t,v} {t,v}\n w ∅ {t,v} ∅","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Now a simple state cannot represent directly this NFA. A transition function delta is used to return and to dispatch on a Tuple of states:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"using YAActL, .Iterators\n\n@enum Q s t u v w   # describe states\n\n# implement the transition function/methods\nδ(::Val{s}, ::Val{'a'}) = (t,v,w)\nδ(::Val{s}, ::Any)      = (s,)        # default transition\nδ(::Val{t}, ::Val{'a'}) = (u,v)\nδ(::Val{t}, ::Val{'b'}) = (u,v)\nδ(::Val{t}, ::Any)      = (t,)\nδ(::Val{u}, ::Val{'a'}) = (s,w)\nδ(::Val{u}, ::Val{'b'}) = (s,w)\nδ(::Val{u}, ::Any)      = (u,)\nδ(::Val{v}, ::Val{'b'}) = (t,v)\nδ(::Val{v}, ::Val{'c'}) = (t,v)\nδ(::Val{v}, ::Any)      = (v,)\nδ(::Val{w}, ::Val{'b'}) = (t,v)\nδ(::Val{w}, ::Any)      = (w,)\nδ(q::Q, c::Char) = δ(Val(q), Val(c))  # function barrier\nδ(qs::Tuple, c::Char) = [δ(q,c) for q in qs] |> flatten |> Set |> Tuple","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"To illustrate how an actor works in state dispatch mode,  we implement a simple iteration function to parse an input string and an actor method:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"# do a simple iteration with a local state variable\nfunction check(str::String)\n    qs = s             # set the initial state 's'\n    for c in str\n        qs = δ(qs, c)  # update state\n    end\n    intersect(qs, (u,v)) |> !isempty\nend\n\n# work with the actor in state dispatch\nfunction check(lk::Link, str::String)\n    update!(mynfa, s)              # set initial state\n    foreach(c->cast!(lk,c), str)   # cast each character\n    intersect(query!(lk), (u,v)) |> !isempty  # check state\nend","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Both implementations follow exactly the same logic. But in the second case the actor maintains state. This enables asynchronous operation: we can send single characters and  query the state anytime.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"An actor is setup in state dispatch mode and checks strings:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"mynfa = Actor(δ)    # an actor with a δ behavior\nset!(mynfa, state)  # is set to state dispatch\n...\n\njulia> check(mynfa, \"aabc\")\ntrue\n\njulia> check(mynfa, \"bbb\")\nfalse","category":"page"},{"location":"examples/state-machines/#Fibonacci-Server","page":"State Machines","title":"Fibonacci Server","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Servers often store data and provide it to clients with some additional computation. One classic example of that is a Fibonacci server. It stores calculated fibonacci numbers in a Dict in order to be able to serve future calls faster:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"using YAActL\n\nfunction fib(D::Dict{Int,BigInt}, n::Int)\n    get!(D, n) do\n        n == 0 && return big(0)\n        n == 1 && return big(1)\n        return fib(D, n-1) + fib(D, n-2)\n    end\nend","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Since D is a mutable variable and fib returns the result, we use the actor's full dispatch mode. We start it with a new empty Dict and can call! it with the desired number n. The actor then updates D as necessary:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"myfib = Actor(fib, Dict{Int,BigInt}())\n\njulia> call!(myfib, 1000)\n43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"The dictionary D is private to the actor.","category":"page"},{"location":"examples/state-machines/#Generic-Function-Servers","page":"State Machines","title":"Generic Function Servers","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"YAActL actors support directives like:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"become!: cause an actor to switch its behavior,\ncall! an actor to execute its behavior function and to send the result,\ncast!: cause an actor to execute its behavior function,\nexec!: tell an actor to execute a function and to send the result.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"They operate as state machines for executing functions. This makes them generic function servers. As shown above the behavior functions may implement state machines as well. They can start other child or siblings actors for doing things. Thus they can represent a hierarchy of state machines.","category":"page"},{"location":"examples/pmap/#Parallel-Map","page":"Parallel Map","title":"Parallel Map","text":"","category":"section"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"Here we compare five executions of comp, a \"heavy\" computation taking 2 seconds:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"using YAActL, .Threads, Distributed\n\nfunction comp(i)  # a \"heavy\" computation\n    sleep(2)\n    return (id=i, thrd=threadid())\nend","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"We can check how long it takes sequentially:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> @time map(comp, 1:5)  # sequential\n 10.024817 seconds (36 allocations: 1.234 KiB)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 1, thrd = 1)\n (id = 2, thrd = 1)\n (id = 3, thrd = 1)\n (id = 4, thrd = 1)\n (id = 5, thrd = 1)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with Julia's Threads:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> @time begin\n            t = map(x->(Threads.@spawn comp(x)), 1:5)\n            map(fetch, t)\n       end\n  2.074831 seconds (150.55 k allocations: 8.045 MiB)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 1, thrd = 2)\n (id = 2, thrd = 3)\n (id = 3, thrd = 5)\n (id = 4, thrd = 4)\n (id = 5, thrd = 6)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with YAActL (we get the results in the USR channel):","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> A = map(i->Actor(parallel(), comp, i), 1:5); # start actors\n\njulia> @time begin\n           foreach(a->call!(a, USR), A)\n           map(x->receive!(USR).y, 1:5)\n       end\n  2.042264 seconds (83.46 k allocations: 4.448 MiB, 0.53% gc time)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 2, thrd = 3)\n (id = 5, thrd = 6)\n (id = 4, thrd = 4)\n (id = 3, thrd = 2)\n (id = 1, thrd = 5)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with Distributed:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> addprocs(4);   # add processes\n\njulia> @everywhere function comp(i)  # a \"heavy\" computation\n           sleep(2)\n           return (id=i, prc=myid())\n       end\n\njulia> @time begin\n            f = map(i->(@spawnat i comp(i)), 1:5)\n            map(fetch, f)\n       end\n  2.252625 seconds (185.30 k allocations: 9.740 MiB, 0.38% gc time)\n5-element Array{NamedTuple{(:id, :prc),Tuple{Int64,Int64}},1}:\n (id = 1, prc = 1)\n (id = 2, prc = 2)\n (id = 3, prc = 3)\n (id = 4, prc = 4)\n (id = 5, prc = 5)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"YAActL actors and Distributed processes are persistent objects. Therefore we must allocate them before we do computations with them. If we work with remote actors on other processes or nodes, we have to ensure as in Distributed that the code is available on each node.","category":"page"},{"location":"patterns/#Actor-Patterns","page":"Actor Patterns","title":"Actor Patterns","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"Here are some things you can do with actors:","category":"page"},{"location":"patterns/#State-Machines","page":"Actor Patterns","title":"State Machines","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"You can use actors to store, search, filter, compose, calculate ... concurrently on a computer or in a network. All those different activities can be seen generally as state machines.","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"State machines have state and react to events. In that basic sense actors are state machines and are particularly well suited to represent them. YAActL actors have been designed to support various approaches to implement state machines.","category":"page"},{"location":"patterns/#Parallel-Computation","page":"Actor Patterns","title":"Parallel Computation","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"... actors provide no direct support for parallelism. ... And because actors do not share state and can only communicate through message passing, they are not a suitable choice if you need fine-grained parallelism. [1]","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"As with Julia's built-in functionality you can parallelize heavy computations quickly with actors. This is shown in the parallel map example.","category":"page"},{"location":"patterns/#Building-Systems","page":"Actor Patterns","title":"Building Systems","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"Actors are composable into systems. ...","category":"page"},{"location":"patterns/#Fault-tolerant-Systems","page":"Actor Patterns","title":"Fault-tolerant Systems","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"The supervisory tree is not yet implemented.","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"[1]: Paul Butcher, Seven Concurrency Models in Seven Weeks.- 2014, The Pragmatic Programmers, p. 152","category":"page"},{"location":"#YAActL.jl","page":"Home","title":"YAActL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yet another Actor Library, concurrent programming in Julia with the Actor model.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to YAActL,\nManual, how to:\nunderstand and use actors,\ncontrol actor behavior,\ndo stuff with them.\nActor API: detailed documentation.\nExamples:\na stack,\na recursive factorial,\nInternals\nmessages to actors,\nactor diagnosis","category":"page"},{"location":"#Rationale","page":"Home","title":"Rationale","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors are an important concept for concurrent computing.\nThere is no actor library in Julia.\nJulia allows to condense the actor-concept into a  smart and fast library.\nA community effort is needed to do it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you agree with those points, please help with  YAActL's development.","category":"page"},{"location":"#Author(s)","page":"Home","title":"Author(s)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YAActL is licensed under the MIT License.","category":"page"}]
}
