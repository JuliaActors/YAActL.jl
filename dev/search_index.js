var documenterSearchIndex = {"docs":
[{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"An Actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL actors are Julia tasks represented by local or remote LINKs, channels over which they receive and send messages [2]. They:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"react to those messages,\nexecute user defined behavior functions when receiving certain messages,\nchange their behavior upon request,\nupdate their internal state influencing how they behave.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL provides various commands to set, control, trigger and query actor behavior and state.","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In the simplest case we start an Actor with a previously implemented behavior and get a link to it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actor","category":"page"},{"location":"actors/#YAActL.Actor","page":"Actors","title":"YAActL.Actor","text":"Actor([lp::LinkParams], bhv::Function, args...; kwargs...)\nActor(pid::Int, bhv::Function, args...; kwargs...)\n\nCreate a new actor. Start a task executing repeatedly the behavior bhv. The actor listens to messages msg sent over the returned link and executes bhv(args..., msg, kwargs) for each message. The actor stops if sent Stop().\n\nArguments\n\n[lp::LinkParams]: optional parameters for creating the actor,\npid::Int: create the actor on process pid,\nbhv::Function: function implementing the actor's behavior,\nargs...: arguments to bhv, (without msg)\nkwargs...: keyword arguments to bhv.\n\nReturns\n\na Link to a locally created actor or \nan RLink to a remote actor.\n\n\n\n\n\n","category":"function"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following code starts an actor with a stack_node behavior function and some arguments to it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack = Actor(stack_node, StackNode(nothing, Link()))","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"We can now send! messages to mystack or do other operations on it.","category":"page"},{"location":"actors/#Operation","page":"Actors","title":"Operation","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"An actor recognizes and operates on predefined messages. Basically there are only two functions to interact with an actor:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!: send a message to an actor,\nreceive!: receive a message,\nrequest!: send a message to an actor, block, receive and return the result.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!\nreceive!\nrequest!","category":"page"},{"location":"actors/#YAActL.send!","page":"Actors","title":"YAActL.send!","text":"send!(lk::LINK, m::Message)\n\nSend a message m to an actor over a LINK lk.\n\n\n\n\n\nsend!(lks::Tuple{LINK,Vararg{LINK}}, m::M) where M<:Message\nsend!(lks::Vector{LINK}, m::M) where M<:Message\n\nSend a message m to a Vector or Tuple of LINKs.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.receive!","page":"Actors","title":"YAActL.receive!","text":"receive!(lk; timeout=5.0)\nreceive!(lk, from; timeout=5.0)\nreceive!(lk, Msg; timeout=5.0)\nreceive!(lk, Msg, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf Msg or from are provided, receive! returns only a  matching message.\n\nParameters\n\nlk::LINK: local or remote link over which the message is sent,\nMsg::Type{<:Message}: Message type,\nfrom::LINK: local or remote link of sender,\ntimeout::Real: maximum waiting time in seconds.\n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.request!","page":"Actors","title":"YAActL.request!","text":"request!(lk::LINK, Msg::Type{<:Message}, args...; full=false)\n\nSend a message of type Msg with optional args... to an  actor over a given LINK lk, block, receive and  return the result.\n\nIf full==true return the full Response message.\n\n\n\n\n\n","category":"function"},{"location":"actors/#Message-API","page":"Actors","title":"Message API","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Users can interact with actors with explicit messages:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Message\nResponse\nRequest\nTimeout","category":"page"},{"location":"actors/#YAActL.Message","page":"Actors","title":"YAActL.Message","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"actors/#YAActL.Response","page":"Actors","title":"YAActL.Response","text":"Response(y, from::LINK=self())\n\nA Message representing a response to requests.\n\n\n\n\n\n","category":"type"},{"location":"actors/#YAActL.Request","page":"Actors","title":"YAActL.Request","text":"Request(x, from::LINK)\n\nA generic Message for user requests.\n\n\n\n\n\n","category":"type"},{"location":"actors/#YAActL.Timeout","page":"Actors","title":"YAActL.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"actors/","page":"Actors","title":"Actors","text":"If an actor receives a Request message or any other not predefined message, it executes its behavior function with this message as the last argument.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"This mechanism can be employed to extend the actor's behavior. A user can implement further message types. For example:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"struct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"actors/#api","page":"Actors","title":"User API","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following interface to actors is for common use:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!: cause an actor to switch its behavior,\ncall!: call an actor to execute its behavior function and to return the result,\ncast!: cause an actor to execute its behavior function,\nget!: get an actor's internal state,\ninit!: tell an actor to execute a function at startup,\nquery!: prompt for the result of the last call to the behavior function,\nself: get your actor's link,\nset!: set the actor's dispatch mode,\nexit!: terminate an actor,\nterm!: tell an actor to execute a function when it terminates.\nupdate!: update an actor's internal state,","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those functions are wrappers to predefined messages and to the send! or request! functions. They all involve a communication.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!\ncall!\ncast!\nBase.get!\nexec!\nexit!\ninit!\nquery!\nupdate!\nset!\nterm!","category":"page"},{"location":"actors/#YAActL.become!","page":"Actors","title":"YAActL.become!","text":"become!(lk::LINK, bhv::Function, args...; kwargs...)\n\nCause an actor to switch its behavior.\n\nArguments\n\nlk::Link: Link to an actor,\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.call!","page":"Actors","title":"YAActL.call!","text":"call!(lk::LINK, [from::LINK], args...)\n\nCall the lk actors behavior function withargs...and  send its returned value as [Response](@ref) to thefromchannel. Iffromis omitted,call!` blocks and returns  the response.\n\nExamples\n\n\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.cast!","page":"Actors","title":"YAActL.cast!","text":"cast!(lk::LINK, args...)\n\nExecute the lk actor's behavior function with args... without sending a response. The returned value of the behavior function can be obtained with query!\n\n\n\n\n\n","category":"function"},{"location":"actors/#Base.get!","page":"Actors","title":"Base.get!","text":"get!(lk::LINK, [from::LINK])\n\nGet a Response message from the lk actor with its  internal state to the from channel. If from  is omitted, get! blocks and returns the response.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.exec!","page":"Actors","title":"YAActL.exec!","text":"exec!(lk::LINK, [from::LINK], f::Function, args...; kwargs...)\n\nTell the lk actor to execute f(args...; kwargs...) and  send the returned value as Response to the from  channel. If from is omitted, exec! blocks and returns  the response value.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.exit!","page":"Actors","title":"YAActL.exit!","text":"exit!(lk::LINK, code=0)\n\nTell an actor lk to exit. If it has a term  function it calls it with code as last argument. \n\nThis is an asynchronous message without a response.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.init!","page":"Actors","title":"YAActL.init!","text":"init!(lk::LINK, f::Function, args...; kwargs...)\n\nTell an actor lk to execute the init function f with the  given arguments at startup and to save the returned value as state variable.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.query!","page":"Actors","title":"YAActL.query!","text":"query!(lk::LINK, [from::LINK])\n\nQuery the result of the last call to the behavior function  from the lk actor. The Response is sent to the from channel. If from is omitted query! blocks and  returns the response.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.update!","page":"Actors","title":"YAActL.update!","text":"update!(lk::LK, args...)\n\nUpdate the lk actor's internal state with args.... This is an asynchronous message without a response.\n\nIt can be called with Args to update the stored arguments to the behavior function. If Args has keyword  arguments, they are merged with existing keyword arguments  to the behavior function.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.set!","page":"Actors","title":"YAActL.set!","text":"set!(lk::LINK, dsp::Dispatch)\n\nSet the lk actor's Dispatch to dsp.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.term!","page":"Actors","title":"YAActL.term!","text":"term!(lk::LINK, f::Function, args...; kwargs...)\n\nTell an actor lk to execute a function f when it  terminates. f must accept a code=0 as last argument.  This is added by the actor to args... when it  exit!s.\n\n\n\n\n\n","category":"function"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can also operate on themselves or rather they send messages to themselves:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become: and actor switches its own behavior,\nself: an actor gets a link to itself,\nstop: an actor stops.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become\nself\nstop","category":"page"},{"location":"actors/#YAActL.become","page":"Actors","title":"YAActL.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.self","page":"Actors","title":"YAActL.self","text":"self()\n\nGet the LINK of your actor.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.stop","page":"Actors","title":"YAActL.stop","text":"stop(code=0)\n\nCause your actor to exit with code.\n\n\n\n\n\n","category":"function"},{"location":"actors/#Actor-State","page":"Actors","title":"Actor State","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"The actor state is internal and is shared with its environment only for diagnostic purposes. The API functions above are a safe way to access actor state.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: They build on Julia's concurrency primitives  @spawn, put! and take! (to/from Channels).","category":"page"},{"location":"links/#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"links/","page":"Links","title":"Links","text":"We send messages to actors and they can send them to others over links. In fact, an actor is only represented by its link which it returns upon creation:","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"Link\nRLink\nLINK","category":"page"},{"location":"links/#YAActL.Link","page":"Links","title":"YAActL.Link","text":"A Channel{Message} type for communicating with local actors.\n\nwarn: Warn\nIn actor systems we always use buffered links to avoid blocking. Responding on an unbuffered or full link causes an actor to block. Link() creates an unbuffered Channel, use Link(32) or newLink() instead!\n\nExample\n\njulia> response = Link(32)\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.RLink","page":"Links","title":"YAActL.RLink","text":"A RemoteChannel{Link} type for communicating with remote actors.\n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.LINK","page":"Links","title":"YAActL.LINK","text":"A Union{Link, RLink} type for communicating with actors. \n\n\n\n\n\n","category":"constant"},{"location":"links/","page":"Links","title":"Links","text":"Actors correspond with other actors over links. There is a default link for users to communicate with actors.","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"USR","category":"page"},{"location":"links/#YAActL.USR","page":"Links","title":"YAActL.USR","text":"User channel for interacting with actors.\n\n\n\n\n\n","category":"constant"},{"location":"links/","page":"Links","title":"Links","text":"For setting up links explicitly we have the following functions.","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"newLink\nLinkParams\nparallel","category":"page"},{"location":"links/#YAActL.newLink","page":"Links","title":"YAActL.newLink","text":"newLink(sz::Integer=32)\n\nCreate a link of buffer size sz to get responses from actors. Buffer sizes sz < 10 are not allowed.\n\nExample\n\njulia> response = newLink()\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"function"},{"location":"links/#YAActL.LinkParams","page":"Links","title":"YAActL.LinkParams","text":"LinkParams(pid=myid(), size=32; taskref=nothing, spawn=false)\n\nParameters for setting up an Actor. \n\npid::Int: process identification,\nsize::Int: channel buffer size, must be size ≥ 10,\ntaskref::Union{Nothing, Ref{Task}}: If you need a reference to the created task,   pass a Ref{Task} object via the keyword argument taskref.\nspawn::Bool: If spawn = true, the Task created may be scheduled on another   thread in parallel, equivalent to creating a task via Threads.@spawn.\n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.parallel","page":"Links","title":"YAActL.parallel","text":"parallel(size=32; taskref=nothing)\n\nReturn LinkParams with spawn=true.\n\nExample\n\njulia> using YAActL, .Threads\n\njulia> myactor = Actor(parallel(), threadid);\n\njulia> call!(myactor)\n2\n\n\n\n\n\n","category":"function"},{"location":"setup/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"setup/","page":"Installation","title":"Installation","text":"YAActL\nYAActL.version","category":"page"},{"location":"setup/#YAActL","page":"Installation","title":"YAActL","text":"YAActL\n\nYet Another Actor Library (in Julia VERSION ≥ v\"1.3\").\n\nThe current stable, registered version is installed with\n\npkg> add YAActL\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/YAActL.jl\")\n\n\n\n\n\n","category":"module"},{"location":"setup/#YAActL.version","page":"Installation","title":"YAActL.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"setup/","page":"Installation","title":"Installation","text":"using YAActL\nYAActL.version","category":"page"},{"location":"examples/factorial/#factorial_example","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"","category":"section"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"This is Agha's example 3.2.2:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Our implementation of the factorial relies on creating a customer which waits for the appropriate communication, in this case from the factorial actor itself. The factorial actor is free to concurrently process the next communication. We assume that a communication to a factorial includes a mail address to which the value of the factorial is to be sent.","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"For a requested factorial x  x  0 the factorial actor creates a customer actor on a parallel thread answering the request and sends itself a request with x-1 from the newly created customer. The created chain of customer actors finally answers the original request. We implement first the behaviors and then setup the factorial actor F and a response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"using YAActL\n\nfunction rec_factorial(f::Request)\n    if f.x == 0\n        send!(f.u, Response(1))\n    else\n        c = Actor(parallel(), rec_customer, f.x, f.u) # setup parallel actors\n        send!(self(), Request(f.x - 1, c))\n    end\nend\n\nfunction rec_customer(n::Integer, u::Link, k::Response) \n    send!(u, Response(n * k.y))\n    stop()\nend\n\nF = Actor(rec_factorial)\nresp = newLink()","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Now we can send requests to the factorial actor and take the answers from the response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"julia>  for i ∈ 0:5:50      # send and receive loop\n            send!(F, Request(big(i), resp))\n            println(take!(resp))\n        end\nResponse{Int64}(1)\nResponse{BigInt}(120)\nResponse{BigInt}(3628800)\nResponse{BigInt}(1307674368000)\nResponse{BigInt}(2432902008176640000)\nResponse{BigInt}(15511210043330985984000000)\nResponse{BigInt}(265252859812191058636308480000000)\nResponse{BigInt}(10333147966386144929666651337523200000000)\nResponse{BigInt}(815915283247897734345611269596115894272000000000)\nResponse{BigInt}(119622220865480194561963161495657715064383733760000000000)\nResponse{BigInt}(30414093201713378043612608166064768844377641568960512000000000000)","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"If we send our requests successively without waiting and then read the response link, we still get the same sequence – which is a bit surprising. For sure this is not the most effective method to implement a factorial.","category":"page"},{"location":"behavior/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = YAActL","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior is a","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"function to express what an actor does when it processes a message [1]","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In the following example we define two behaviors forward! and stack_node. There are two methods for stack_node, dispatching on Push and Pop.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"behavior/#dispatch","page":"Behaviors","title":"Behavior Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"A behavior function can be implemented with different methods. Then Julia dispatches the methods based on the function arguments [2].","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"YAActL actors use multiple dispatch of behavior methods by passing the incoming message as last argument to the behavior function.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In the above example the actor dispatches the stack_node methods regarding to whether the incoming message is a Pop or a Push. On its creation as Actor(stack_node, sn) it gets only the first argument sn to the stack_node function. When a message msg arrives, it gets the second argument and can compose the arguments to the behavior and call it as stack_node(sn, msg).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"If the actor tries to pass another message than Pop or Push to stacknode(sn, msg) it will fail with an ArgumentError.","category":"page"},{"location":"behavior/#Dispatch-Mode","page":"Behaviors","title":"Dispatch Mode","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"An actor's dispatch mode determines how it","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"composes the arguments to the behavior function and\nuses the function's returned value.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Dispatch","category":"page"},{"location":"behavior/#YAActL.Dispatch","page":"Behaviors","title":"YAActL.Dispatch","text":"Dispatch\n\nEnumeration type for dispatch modes of actors.\n\nDepending on the Dispatch mode the actor composes the arguments  to the behavior function:\n\nfull: from the Become args... and the msg.x....   This is the default dispatch mode.\nstate: from the actor state and the msg.x.... In this case the    actor updates its state with the result of the behavior   function. The result is saved in a Tuple. \n\n\n\n\n\n","category":"type"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Above we used full dispatch. With Actor(stack_node, sn) the actor got sn as the first argument and can use that to represent state. If it is mutable, a behavior function can even change its content.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"With state dispatch mode we use the actors internal state sta as first argument to the behavior function. When a message msg arrives, the actor calls its behavior function as bhv(sta, msg) and saves the returned value in its internal state variable sta. Thus it is possible to implement a finite-state machine. This is a more functional approach.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Note that actor state can be set with init! and update!.","category":"page"},{"location":"behavior/#composition","page":"Behaviors","title":"More on Argument Composition","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The YAActL API allows to send arbitrary arguments to a behavior function. First you install an actor behavior bhv with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"act = Actor(bhv, args1...) or\nbecome!(act, bhv, args1...).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Then you deliver the second part of the arguments with ","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"call!(act, args2...) or\ncast!(act, args2...) or\nsend!(act, msg.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The act actor then executes bhv((args1..., args2...)...) or bhv((args1..., msg)...) respectively. Also empty arguments args1... or args2... are allowed as long as their composition is understood by the behavior function bhv.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The actor eventually passes keyword arguments kwargs... to the behavior function. But those are not dispatched on.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"As programmer of an actor system you influence this mechanism in three ways:","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"First you implement the needed behavior methods with the full number of arguments.\nIn setting the actor's dispatch mode with set! and by delivering the first part of arguments to the behavior function in Actor and become! you determine the state-dependent arguments.\nIn delivering messages with call!, cast! and send! you determine the (message-dependent) second part of arguments.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"All this can be used to implement quite complex actor behavior","category":"page"},{"location":"behavior/#Changing-Behavior","page":"Behaviors","title":"Changing Behavior","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior can be set with become! and respectively behavior functions can cause their actor to switch to another behavior with become.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[2]: see also JuliaCon 2019 | The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = YAActL","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages in YAActL have Message as a common abstract type. Only two predefined messages are exported:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Response: response message type from actor to any synchronous message (requiring a response),\nRequest: predefined message type for implementing requests to actors.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages other than the predefined ones can be implemented by a user.","category":"page"},{"location":"messages/#Sending-Functions-and-Arguments","page":"Messages","title":"Sending Functions and Arguments","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are two predefined types for messages with functions and function arguments:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Func\nArgs","category":"page"},{"location":"messages/#YAActL.Func","page":"Messages","title":"YAActL.Func","text":"Func(f, args...; kwargs...)\n\nA structure for passing a function f and its arguments to an actor.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Args","page":"Messages","title":"YAActL.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors recognize and react to the following predefined messages:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nDiag\nExec\nGet\nInit\nQuery\nSet\nStop\nTerm\nUpdate","category":"page"},{"location":"messages/#YAActL.Become","page":"Messages","title":"YAActL.Become","text":"Become(x::Func)\n\nAn asynchronous Message to an actor to change its  behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Call","page":"Messages","title":"YAActL.Call","text":"Call(arg, from::LINK)\n\nA synchronous Message to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Cast","page":"Messages","title":"YAActL.Cast","text":"Cast(arg)\n\nAn asynchronous Message to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Diag","page":"Messages","title":"YAActL.Diag","text":"Diag(from::LINK)\n\nA synchronous Message to an actor to send a  Response message with its internal _ACT variable to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Exec","page":"Messages","title":"YAActL.Exec","text":"Exec(func::Func, from::LINK)\n\nA synchronous Message to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Get","page":"Messages","title":"YAActL.Get","text":"Get(from::LINK)\n\nA synchronous Message to an actor to send a  Response message with its internal state to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Init","page":"Messages","title":"YAActL.Init","text":"Init(f::Func)\n\nA Message to an actor to execute the given Func and to register it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Query","page":"Messages","title":"YAActL.Query","text":"Query(from::LINK)\n\nA synchronous Message to an actor to return the result of the last execution of the behavior function.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Set","page":"Messages","title":"YAActL.Set","text":"Set(dsp::Dispatch)\nSet(lk::LINK)\n\nAn asynchronous Message to an actor to set its  Dispatch behavior or its LINK.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Stop","page":"Messages","title":"YAActL.Stop","text":"Stop(code=0)\n\nA Message causing an actor to stop with an exit code. If present, it calls its term! function with code as last argument.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Term","page":"Messages","title":"YAActL.Term","text":"Term(x::Func)\n\nA Message to an actor to save the given Func  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Update","page":"Messages","title":"YAActL.Update","text":"Update(x)\n\nAn asynchronous Message to an actor to update its  internal state to x. If x is a Args then the arguments to the behavior function are updated.\n\n\n\n\n\n","category":"type"},{"location":"messages/","page":"Messages","title":"Messages","text":"If an actor receives another subtype of Message, it calls its behavior function with it as last argument.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A YAActL actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"is a task running on a thread or a remote node which\nreceives messages over a channel and with it\ndispatches a function or one of of its methods.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using YAActL, Printf\n\n# define two functions for printing a message\nfunction pr(msg)\n    print(@sprintf(\"%s\\n\", msg))\n    become(pr, \"Next\") # change behavior\nend\npr(info, msg) = print(@sprintf(\"%s: %s\\n\", info, msg))\n\n# a function for doing arithmetic\ncalc(op::F, x, y) where F<:Function = op(x, y)\n\n# start an actor with the first behavior\nmyactor = Actor(pr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now we can interact with it:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"My first actor\")     # send a message to it\nMy first actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor has executed its behavior function pr with the message as argument. You may have noticed above that pr(msg) causes the actor to change its behavior to pr(\"Next:\", msg). Now we send it something else:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"Something else\")     # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\") # change the behavior to another one\n\njulia> cast!(myactor, \"bla bla bla\")        # and send again a message\nNew behavior: bla bla bla","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor can also change to a completely different behavior and do some arithmetic:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> become!(myactor, calc, +, 10);       # now become a machine for adding to 10\n\njulia> call!(myactor, 5)                    # send a request to add 5 to it and to return the result\n15\n\njulia> become!(myactor, ^);                 # become an exponentiation machine\n\njulia> call!(myactor, 123, 456)             # try it\n2409344748064316129","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Actors thus can represent different and changing behaviors of real world or computational objects.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If we implement and start multiple actors interacting with each other, we get an actor system.","category":"page"},{"location":"examples/stack/#stack_example","page":"A Stack","title":"A Stack","text":"","category":"section"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"This is Agha's example 3.2.1. It implements a stack as a collection of actors with two operations/messages Push and Pop. A StackNode stores a content and a Link to the next Actor in the chain.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can affect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"We define types for stack nodes and messages. We want our stack actor to dispatch its behavior on push and pop.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"using YAActL\n\nmutable struct StackNode{T}\n    content::T\n    link::Link\nend\n\n# define the messages\nstruct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"The code implementing the actor's behavior is very similar to Agha's example:","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"Then we create the top of the stack (the receptionist). All other actors of the system are created internally each time we send a Push message. We interact only with the top of the stack:","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"julia> mystack = Actor(stack_node, StackNode(nothing, Link()))\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> response = newLink()           # create a response link\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> send!(mystack, Push(1))        # push 1 on the stack\n\njulia> send!(mystack, Pop(response))  # pop it\n\njulia> take!(response)                # returns 1, 1st node now forwards messages\nResponse{Int64}(1)\n\njulia> send!(mystack, Pop(response))  # pop again\n\njulia> take!(response)                # now nothing is left\nResponse{Nothing}(nothing)\n\njulia> for i ∈ 1:5\n           send!(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send!(mystack, Pop(response))\n           println(take!(response))\n       end\nResponse{Int64}(5)\nResponse{Int64}(4)\nResponse{Int64}(3)\nResponse{Int64}(2)\nResponse{Int64}(1)","category":"page"},{"location":"diagnosis/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"CurrentModule = YAActL","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. You can register! an actor channel to a Vector{Link} in order to get access to the tasks.","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"register!\nistaskfailed(::Link)\nistaskfailed(::Vector{Link})\ntaskstate","category":"page"},{"location":"diagnosis/#YAActL.register!","page":"Diagnosis","title":"YAActL.register!","text":"register!(lks::Vector{Link}, lk::Link)\n\nRegister a link lk to a vector of links lks.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Channel{Message}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Array{Channel{Message},1}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lks::Vector{Link})\n\nReturns true if any task associated with a vector lks of links has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#YAActL.taskstate","page":"Diagnosis","title":"YAActL.taskstate","text":"taskstate(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"For diagnostic purposes it is possible to get access to the actor's ACT variable:","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"diag!","category":"page"},{"location":"diagnosis/#YAActL.diag!","page":"Diagnosis","title":"YAActL.diag!","text":"diag!(lk::LINK)\n\nReturn the internal _ACT variable of the lk actor. This is only for diagnosis and testing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#state","page":"Actor State","title":"Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"CurrentModule = YAActL","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"YAActL follows Julia's philosophy in giving the user responsibility for access to internals and implementing correct programs:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"You are entirely responsible for ensuring that your program is data-race free, and nothing promised here can be assumed if you do not observe that requirement. The observed results may be highly unintuitive. [1]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"When using multi-threading we have to be careful when using functions that are not pure as we might get a wrong answer. [2]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Since concurrency is the overarching theme of actor programming and behavior functions must access data to do their job, data-race freedom is a major concern in working with actors. As a ground rule actors don't share state.","category":"page"},{"location":"internals/#Internal-State","page":"Actor State","title":"Internal State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Actors have an internal mutable state variable: ","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"_ACT","category":"page"},{"location":"internals/#YAActL._ACT","page":"Actor State","title":"YAActL._ACT","text":"_ACT(lk::LINK)\n\nInternal actor status variable.\n\nFields\n\ndsp::Dispatch: dispatch mode,\nsta::Tuple: the actor's status variable,\nres::Tuple: the result of the last behavior execution,\nbhv::Func : the behavior function and its internal arguments,\ninit::Func: the init function and its arguments,\nterm::Func: the terminate function and its arguments,\nlink::LINK: the actors (local or remote) link.\n\nsee also: Dispatch, Func, LINK\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Functions executed by an actor can access their actor's internal ACT variable via task_local_storage(\"ACT\").  Normally this is not needed.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"We must express two important concerns regarding actor state:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"note: Actor state is multifaceted!\nActor state is not a single value but includes behavior functions, arguments and an explicit mutable state variable, which is used for state Dispatch or for representing agents.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"warning: Sharing state can cause critical race conditions!\nYou must be careful not to share any of the state variables between actors in order to avoid critical race conditions.","category":"page"},{"location":"internals/#Create-Private-Actor-State","page":"Actor State","title":"Create Private Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"The returned value of the init! function is saved as an actors state sta. It is a good practice to have an init function to create a private actor state with defined initial parameters.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Be careful to update! the actor's state since it overwrites it. Don't update it with a shared variable.","category":"page"},{"location":"internals/#Update-Actor-State","page":"Actor State","title":"Update Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Only the actor itself is allowed to update its state in a strictly sequential manner by processing message after message.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Other actors or users can cause an actor to update its state by sending it a message, which is done implicitly by using the API functions.","category":"page"},{"location":"internals/#Behavior-Function-Arguments","page":"Actor State","title":"Behavior Function Arguments","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Julia functions accept mutable types as parameters and  can change their values. If your behavior functions get mutable types as parameters, you must ensure that","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"either you don't share those variables between actors\nor you don't change them by using only pure functions as behavior.","category":"page"},{"location":"internals/#Global-State","page":"Actor State","title":"Global State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Race conditions can happen if actors in parallel use or modify global variables. The best advice is not to use global variables or at least not to share them between actors.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"If for some reason you want to use global variables and share them between actors, you must use the lock pattern or atomic operations described in the Julia manual. But both approaches block an actor until it succeeds to access the variable.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[1]: see: Data-race freedom in the Julia manual.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[2]: see: Side effects and mutable function arguments in the Julia manual.","category":"page"},{"location":"patterns/#Actor-Patterns","page":"Actor Patterns","title":"Actor Patterns","text":"","category":"section"},{"location":"patterns/#Become-Pattern","page":"Actor Patterns","title":"Become-Pattern","text":"","category":"section"},{"location":"patterns/#Automaton-Pattern","page":"Actor Patterns","title":"Automaton-Pattern","text":"","category":"section"},{"location":"patterns/#Supervisor-Pattern","page":"Actor Patterns","title":"Supervisor-Pattern","text":"","category":"section"},{"location":"#YAActL.jl","page":"Home","title":"YAActL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yet another Actor Library (built in Julia)","category":"page"},{"location":"","page":"Home","title":"Home","text":"YAActL is a library for concurrent computing in Julia based on the Actor model.","category":"page"},{"location":"#Documentation-Overview","page":"Home","title":"Documentation Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to YAActL,\nManual, how to:\nsetup YAActL,\nstart and operate actors,\nunderstand links to actors,\nunderstand and define actor behaviors,\nExamples:\na stack,\na recursive factorial,\nInternals\nmessages to actors,\nactor diagnosis","category":"page"},{"location":"#Rationale","page":"Home","title":"Rationale","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors are an important concept for concurrent computing.\nThere is no actor library in Julia. \nJulia allows to condense the actor-concept into a  smart and fast library.\nA community effort is needed to do it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you agree with those points, please help with  YAActL's development.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Actor model on Wikipedia\nGul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press\nVaughn Vernon: Reactive Messaging Patterns with the Actor Model, Applications and Integrations in Scala and Akka.- 2016, Pearson\nJoe Armstrong: Programming Erlang, 2nd ed., Software for a Concurrent World.- 2013 Pragmatic Programmers","category":"page"},{"location":"#Author(s)","page":"Home","title":"Author(s)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YAActL is licensed under the MIT License.","category":"page"}]
}
