<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>State Machines · YAActL.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">YAActL.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../actors/">Actors</a></li><li><a class="tocitem" href="../../behavior/">Behaviors</a></li><li><a class="tocitem" href="../../patterns/">Actor Patterns</a></li></ul></li><li><a class="tocitem" href="../../api/">Actor API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../stack/">A Linked List of Actors</a></li><li><a class="tocitem" href="../factorial/">A Recursive Factorial</a></li><li class="is-active"><a class="tocitem" href>State Machines</a><ul class="internal"><li><a class="tocitem" href="#DFAs,-behavior-switch"><span>DFAs, behavior-switch</span></a></li><li><a class="tocitem" href="#NFAs,-state-dispatch"><span>NFAs, state-dispatch</span></a></li><li><a class="tocitem" href="#Fibonacci-Server"><span>Fibonacci Server</span></a></li><li><a class="tocitem" href="#Generic-Function-Servers"><span>Generic Function Servers</span></a></li></ul></li><li><a class="tocitem" href="../pmap/">Parallel Map</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../messages/">Messages</a></li><li><a class="tocitem" href="../../internals/">Actor State</a></li><li><a class="tocitem" href="../../diagnosis/">Diagnosis</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../_index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>State Machines</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>State Machines</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/pbayer/YAActL.jl/blob/master/docs/src/examples/state-machines.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="State-Machines"><a class="docs-heading-anchor" href="#State-Machines">State Machines</a><a id="State-Machines-1"></a><a class="docs-heading-anchor-permalink" href="#State-Machines" title="Permalink"></a></h1><p>There are various ways to implement state machines with actors. The following examples illustrate how actors operate as state machines and are not to propose actual implementations.</p><h2 id="DFAs,-behavior-switch"><a class="docs-heading-anchor" href="#DFAs,-behavior-switch">DFAs, behavior-switch</a><a id="DFAs,-behavior-switch-1"></a><a class="docs-heading-anchor-permalink" href="#DFAs,-behavior-switch" title="Permalink"></a></h2><p>Behavior-switch is the most elegant way to implement a finite state machine with an actor.</p><p>Take a <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite automaton</a> with four states <span>$\{s,q,p,r\}$</span>, three inputs <span>$\{a,b,c\}$</span> and the transition function <span>$δ$</span> represented in a table:</p><table><tr><th style="text-align: right"><span>$\;$</span></th><th style="text-align: right"><span>$\;$</span></th><th style="text-align: center">a</th><th style="text-align: center">b</th><th style="text-align: center">c</th></tr><tr><td style="text-align: right">initial state</td><td style="text-align: right">-&gt; <strong>s</strong></td><td style="text-align: center">s</td><td style="text-align: center">q</td><td style="text-align: center">s</td></tr><tr><td style="text-align: right"></td><td style="text-align: right"><strong>p</strong></td><td style="text-align: center">p</td><td style="text-align: center">q</td><td style="text-align: center">p</td></tr><tr><td style="text-align: right"></td><td style="text-align: right"><strong>q</strong></td><td style="text-align: center">p</td><td style="text-align: center">r</td><td style="text-align: center">r</td></tr><tr><td style="text-align: right">accepting state</td><td style="text-align: right">* <strong>r</strong></td><td style="text-align: center">r</td><td style="text-align: center">r</td><td style="text-align: center">r</td></tr></table><p>The state-transition table can be implemented directly:</p><pre><code class="language-julia">using YAActL

s(::Val{&#39;b&#39;}) = become(q)  # implement behaviors
s(x) = nothing             # default transition
p(::Val{&#39;b&#39;}) = become(q)
p(x) = nothing
q(::Val{&#39;a&#39;}) = become(p)
q(::Val{&#39;b&#39;}) = become(r)
q(::Val{&#39;c&#39;}) = become(r)
q(x) = nothing
r(x) = nothing</code></pre><p>DFA-states are directly represented by behavior functions. Those switch behavior/state on certain input values or otherwise do nothing.</p><p>The actor ist started with the initial behavior. A <code>check</code> function parses input strings:</p><pre><code class="language-julia">mydfa = Actor(s)

function check(lk::Link, str::String)
    become!(lk, s)         # switch to initial state
    foreach(str) do c
        cast!(lk, Val(c))  # send all chars to the actor
    end
    query!(lk, :bhv) == r  # check the final state
end</code></pre><p>It checks which strings get accepted:</p><pre><code class="language-julia">julia&gt; check(mydfa, &quot;baab&quot;)
false

julia&gt; check(mydfa, &quot;baabc&quot;)
true

julia&gt; check(mydfa, &quot;babaccabb&quot;)
true</code></pre><h2 id="NFAs,-state-dispatch"><a class="docs-heading-anchor" href="#NFAs,-state-dispatch">NFAs, state-dispatch</a><a id="NFAs,-state-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#NFAs,-state-dispatch" title="Permalink"></a></h2><p>Non-deterministic finite automata can have more complex states, and more than one transition can happen at an input event.</p><table><tr><th style="text-align: right"><span>$\;$</span></th><th style="text-align: right"><span>$\;$</span></th><th style="text-align: center">a</th><th style="text-align: center">b</th><th style="text-align: center">c</th></tr><tr><td style="text-align: right">initial state</td><td style="text-align: right">-&gt; <strong>s</strong></td><td style="text-align: center">{t,v,w}</td><td style="text-align: center">∅</td><td style="text-align: center">∅</td></tr><tr><td style="text-align: right"></td><td style="text-align: right"><strong>t</strong></td><td style="text-align: center">{u,v}</td><td style="text-align: center">{u,v}</td><td style="text-align: center">∅</td></tr><tr><td style="text-align: right">accepting state</td><td style="text-align: right">* <strong>u</strong></td><td style="text-align: center">{s,w}</td><td style="text-align: center">{s,w}</td><td style="text-align: center">∅</td></tr><tr><td style="text-align: right">accepting state</td><td style="text-align: right">* <strong>v</strong></td><td style="text-align: center">∅</td><td style="text-align: center">{t,v}</td><td style="text-align: center">{t,v}</td></tr><tr><td style="text-align: right"></td><td style="text-align: right"><strong>w</strong></td><td style="text-align: center">∅</td><td style="text-align: center">{t,v}</td><td style="text-align: center">∅</td></tr></table><p>Now a simple state cannot represent directly this NFA. A transition function <span>$\delta$</span> is used to return and to dispatch on a <code>Tuple</code> of states:</p><pre><code class="language-julia">using YAActL, .Iterators

@enum Q s t u v w   # describe states

# implement the transition function/methods
δ(::Val{s}, ::Val{&#39;a&#39;}) = (t,v,w)
δ(::Val{s}, ::Any)      = (s,)        # default transition
δ(::Val{t}, ::Val{&#39;a&#39;}) = (u,v)
δ(::Val{t}, ::Val{&#39;b&#39;}) = (u,v)
δ(::Val{t}, ::Any)      = (t,)
δ(::Val{u}, ::Val{&#39;a&#39;}) = (s,w)
δ(::Val{u}, ::Val{&#39;b&#39;}) = (s,w)
δ(::Val{u}, ::Any)      = (u,)
δ(::Val{v}, ::Val{&#39;b&#39;}) = (t,v)
δ(::Val{v}, ::Val{&#39;c&#39;}) = (t,v)
δ(::Val{v}, ::Any)      = (v,)
δ(::Val{w}, ::Val{&#39;b&#39;}) = (t,v)
δ(::Val{w}, ::Any)      = (w,)
δ(q::Q, c::Char) = δ(Val(q), Val(c))  # function barrier
δ(qs::Tuple, c::Char) = [δ(q,c) for q in qs] |&gt; flatten |&gt; Set |&gt; Tuple</code></pre><p>To illustrate how an actor works in <code>state</code> dispatch mode,  we implement a simple iteration function to parse an input string and an actor method:</p><pre><code class="language-julia"># do a simple iteration with a local state variable
function check(str::String)
    qs = s             # set the initial state &#39;s&#39;
    for c in str
        qs = δ(qs, c)  # update state
    end
    intersect(qs, (u,v)) |&gt; !isempty
end

# work with the actor in state dispatch
function check(lk::Link, str::String)
    update!(mynfa, s)              # set initial state
    foreach(c-&gt;cast!(lk,c), str)   # cast each character
    intersect(query!(lk), (u,v)) |&gt; !isempty  # check state
end</code></pre><p>Both implementations follow exactly the same logic. But in the second case the actor maintains state. This enables asynchronous operation: we can send single characters and  query the state anytime.</p><p>An actor is setup in <code>state</code> dispatch mode and checks strings:</p><pre><code class="language-julia">mynfa = Actor(δ)    # an actor with a δ behavior
set!(mynfa, state)  # is set to state dispatch
...

julia&gt; check(mynfa, &quot;aabc&quot;)
true

julia&gt; check(mynfa, &quot;bbb&quot;)
false</code></pre><h2 id="Fibonacci-Server"><a class="docs-heading-anchor" href="#Fibonacci-Server">Fibonacci Server</a><a id="Fibonacci-Server-1"></a><a class="docs-heading-anchor-permalink" href="#Fibonacci-Server" title="Permalink"></a></h2><p>Servers often store data and provide it to clients with some additional computation. One classic example of that is a Fibonacci server. It stores calculated fibonacci numbers in a <code>Dict</code> in order to be able to serve future calls faster:</p><pre><code class="language-julia">using YAActL

function fib(D::Dict{Int,BigInt}, n::Int)
    get!(D, n) do
        n == 0 &amp;&amp; return big(0)
        n == 1 &amp;&amp; return big(1)
        return fib(D, n-1) + fib(D, n-2)
    end
end</code></pre><p>Since <code>D</code> is a mutable variable and <code>fib</code> returns the result, we use the actor&#39;s <code>full</code> dispatch mode. We start it with a new empty <code>Dict</code> and can <code>call!</code> it with the desired number <code>n</code>. The actor then updates <code>D</code> as necessary:</p><pre><code class="language-julia">myfib = Actor(fib, Dict{Int,BigInt}())

julia&gt; call!(myfib, 1000)
43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875</code></pre><p>The dictionary <code>D</code> is private to the actor.</p><h2 id="Generic-Function-Servers"><a class="docs-heading-anchor" href="#Generic-Function-Servers">Generic Function Servers</a><a id="Generic-Function-Servers-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Function-Servers" title="Permalink"></a></h2><p><code>YAActL</code> actors support directives like:</p><ul><li><a href="../../api/#YAActL.become!"><code>become!</code></a>: cause an actor to switch its behavior,</li><li><a href="../../api/#YAActL.call!"><code>call!</code></a> an actor to execute its behavior function and to send the result,</li><li><a href="../../api/#YAActL.cast!"><code>cast!</code></a>: cause an actor to execute its behavior function,</li><li><a href="../../api/#YAActL.exec!"><code>exec!</code></a>: tell an actor to execute a function and to send the result.</li></ul><p>They operate as state machines for executing functions. This makes them generic function servers. As shown above the behavior functions may implement state machines as well. They can start other child or siblings actors for doing things. Thus they can represent a hierarchy of state machines.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../factorial/">« A Recursive Factorial</a><a class="docs-footer-nextpage" href="../pmap/">Parallel Map »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 7 November 2020 12:53">Saturday 7 November 2020</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
