var documenterSearchIndex = {"docs":
[{"location":"behavior/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Actors are created with a behavior function. When a message arrives, they execute their behavior reacting to it.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Therefore the behavior function must take a Message as its last argument.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In the following example we define two behaviors forward! and stack_node. There are two methods for stack_node, dispatching on Push and Pop.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"behavior/#Dispatching-on-Messages","page":"Behaviors","title":"Dispatching on Messages","text":"","category":"section"},{"location":"behavior/#Changing-Behavior","page":"Behaviors","title":"Changing Behavior","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Actors can change their own behavior or cause other actors to switch behavior.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"become\nbecome!","category":"page"},{"location":"behavior/#YAActL.become","page":"Behaviors","title":"YAActL.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause yourself to take on a new behavior. Called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"behavior/#YAActL.become!","page":"Behaviors","title":"YAActL.become!","text":"become!(lk::LINK, bhv::Function, args...; kwargs...)\n\nCause another actor to assume a new behavior.\n\nArguments\n\nlk::Link: Link to an actor,\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages in YAActL have a common abstract type. This enables actors to dispatch their behavior functions on message types.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Some basic message types are for setting up the type hierarchy and for controlling the actors themselves:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Message\nStop\nYAActL.Become","category":"page"},{"location":"messages/#YAActL.Message","page":"Messages","title":"YAActL.Message","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Stop","page":"Messages","title":"YAActL.Stop","text":"Stop()\n\nA message causing an actor to stop.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Become","page":"Messages","title":"YAActL.Become","text":"Become(f::Function, args...; kwargs...)\n\nInternal message for behavior change.\n\n\n\n\n\n","category":"type"},{"location":"messages/","page":"Messages","title":"Messages","text":"The following message types are for executing and dispatching standard behaviors:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Request\nResponse","category":"page"},{"location":"messages/#YAActL.Request","page":"Messages","title":"YAActL.Request","text":"Request(x, lk::LINK)\n\nA message representing a request of x by customer lk.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Response","page":"Messages","title":"YAActL.Response","text":"Response(y)\n\nA message representing a response of y to a request.\n\n\n\n\n\n","category":"type"},{"location":"messages/","page":"Messages","title":"Messages","text":"Other message types can be implemented by the user, for example:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"struct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"With dispatch on message types we can easily implement state machines.","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"An Actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL provides a library for messages, links (message channels), behaviors and actors which enables us to implement actor systems in Julia.","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actor starts an actor on a behavior and returns a link to it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actor","category":"page"},{"location":"actors/#YAActL.Actor","page":"Actors","title":"YAActL.Actor","text":"Actor([lp::LinkParams], bhv::Function, args...; kwargs...)\nActor(pid::Int, bhv::Function, args...; kwargs...)\n\nCreate a new actor. Start a task executing repeatedly the behavior bhv. The actor listens to messages msg sent over the returned link and executes bhv(args..., msg, kwargs) for each message. The actor stops if sent Stop().\n\nArguments\n\n[lp::LinkParams]: optional parameters for creating the actor,\npid::Int: create the actor on process pid,\nbhv::Function: function implementing the actor's behavior,\nargs...: arguments to bhv, (without msg)\nkwargs...: keyword arguments to bhv.\n\nReturns\n\na Link to a locally created actor or \nan RLink to a remote actor.\n\n\n\n\n\n","category":"function"},{"location":"actors/#Example","page":"Actors","title":"Example","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In the following code snippet we start an actor with a stack_node behavior function and one of its arguments (an empty StackNode).","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack = Actor(stack_node, StackNode(nothing, Link()))","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"We saved the returned link in mystack and can now send! messages to it.","category":"page"},{"location":"actors/#Operation","page":"Actors","title":"Operation","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"If an actor gets a message, it executes its behavior function with it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can switch their behavior function with become or we can cause them to switch it with become!. Thereby an actor can represent a state machine.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"We can stop an Actor.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"stopActor\nstopActor!","category":"page"},{"location":"actors/#YAActL.stopActor","page":"Actors","title":"YAActL.stopActor","text":"stopActor(): an actor terminates.\n\n\n\n\n\n","category":"function"},{"location":"actors/#YAActL.stopActor!","page":"Actors","title":"YAActL.stopActor!","text":"stopActor!(lk::LINK): terminate an actor with link lk.\n\n\n\n\n\n","category":"function"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#stack_example","page":"Examples","title":"A Stack","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is Agha's example 3.2.1. It implements a stack as a collection of actors with two operations/messages Push and Pop. A StackNode stores a content and a Link to the next Actor in the chain.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can affect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define types for stack nodes and messages. We want our stack actor to dispatch its behavior on push and pop.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using YAActL\n\nmutable struct StackNode{T}\n    content::T\n    link::Link\nend\n\n# define the messages\nstruct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The code implementing the actor's behavior is very similar to Agha's example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we create the top of the stack (the receptionist). All other actors of the system are created internally each time we send a Push message. We interact only with the top of the stack:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> mystack = Actor(stack_node, StackNode(nothing, Link()))\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> response = newLink()           # create a response link\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> send!(mystack, Push(1))        # push 1 on the stack\n\njulia> send!(mystack, Pop(response))  # pop it\n\njulia> take!(response)                # returns 1, 1st node now forwards messages\nResponse{Int64}(1)\n\njulia> send!(mystack, Pop(response))  # pop again\n\njulia> take!(response)                # now nothing is left\nResponse{Nothing}(nothing)\n\njulia> for i ∈ 1:5\n           send!(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send!(mystack, Pop(response))\n           println(take!(response))\n       end\nResponse{Int64}(5)\nResponse{Int64}(4)\nResponse{Int64}(3)\nResponse{Int64}(2)\nResponse{Int64}(1)","category":"page"},{"location":"examples/#factorial_example","page":"Examples","title":"A Recursive Factorial","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is Agha's example 3.2.2:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our implementation of the factorial relies on creating a customer which waits for the appropriate communication, in this case from the factorial actor itself. The factorial actor is free to concurrently process the next communication. We assume that a communication to a factorial includes a mail address to which the value of the factorial is to be sent.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For a requested factorial x  x  0 the factorial actor creates a customer actor on a parallel thread answering the request and sends itself a request with x-1 from the newly created customer. The created chain of customer actors finally answers the original request. We implement first the behaviors and then setup the factorial actor F and a response link:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using YAActL\n\nfunction rec_factorial(f::Request)\n    if f.x == 0\n        send!(f.u, Response(1))\n    else\n        c = Actor(parallel(), rec_customer, f.x, f.u) # setup parallel actors\n        send!(self(), Request(f.x - 1, c))\n    end\nend\n\nfunction rec_customer(n::Integer, u::Link, k::Response) \n    send!(u, Response(n * k.y))\n    stop()\nend\n\nF = Actor(rec_factorial)\nresp = newLink()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can send requests to the factorial actor and take the answers from the response link:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia>  for i ∈ 0:5:50      # send and receive loop\n            send!(F, Request(big(i), resp))\n            println(take!(resp))\n        end\nResponse{Int64}(1)\nResponse{BigInt}(120)\nResponse{BigInt}(3628800)\nResponse{BigInt}(1307674368000)\nResponse{BigInt}(2432902008176640000)\nResponse{BigInt}(15511210043330985984000000)\nResponse{BigInt}(265252859812191058636308480000000)\nResponse{BigInt}(10333147966386144929666651337523200000000)\nResponse{BigInt}(815915283247897734345611269596115894272000000000)\nResponse{BigInt}(119622220865480194561963161495657715064383733760000000000)\nResponse{BigInt}(30414093201713378043612608166064768844377641568960512000000000000)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we send our requests successively without waiting and then read the response link, we still get the same sequence – which is a bit surprising. For sure this is not the most effective method to implement a factorial.","category":"page"},{"location":"diagnosis/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. You can register! an actor channel to a Vector{Link} in order to get access to the tasks.","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"register!\nistaskfailed(::Link)\nistaskfailed(::Vector{Link})\ntaskstate","category":"page"},{"location":"diagnosis/#YAActL.register!","page":"Diagnosis","title":"YAActL.register!","text":"register!(lks::Vector{Link}, lk::Link)\n\nRegister a link lk to a vector of links lks.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Channel{Message}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Array{Channel{Message},1}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lks::Vector{Link})\n\nReturns true if any task associated with a vector lks of links has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#YAActL.taskstate","page":"Diagnosis","title":"YAActL.taskstate","text":"taskstate(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"links/#Links","page":"Links","title":"Links","text":"","category":"section"},{"location":"links/","page":"Links","title":"Links","text":"We send messages to actors and they can send them to others over links. In fact, an actor is only represented by its link which it returns upon creation:","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"Link\nRLink\nLINK\nsend!","category":"page"},{"location":"links/#YAActL.Link","page":"Links","title":"YAActL.Link","text":"A Channel{Message} type for communicating with local actors.\n\nwarn: Warn\nIn actor systems we always use buffered links to avoid blocking. Responding on an unbuffered or full link causes an actor to block. Link() creates an unbuffered Channel, use Link(32) or newLink() instead!\n\nExample\n\njulia> response = Link(32)\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.RLink","page":"Links","title":"YAActL.RLink","text":"A RemoteChannel{Link} type for communicating with remote actors.\n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.LINK","page":"Links","title":"YAActL.LINK","text":"A Union{Link, RLink} type for communicating with actors. \n\n\n\n\n\n","category":"constant"},{"location":"links/#YAActL.send!","page":"Links","title":"YAActL.send!","text":"send!(lk::LINK, m::Message)\n\nSend a message m to an actor over a LINK lk.\n\n\n\n\n\nsend!(lks::Tuple{LINK,Vararg{LINK}}, m::M) where M<:Message\nsend!(lks::Vector{LINK}, m::M) where M<:Message\n\nSend a message m to a Vector or Tuple of LINKs.\n\n\n\n\n\n","category":"function"},{"location":"links/","page":"Links","title":"Links","text":"Actors correspond with other actors over links. If we want a response from an actor, we must send it our own link together with a request message.","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"self()\nUSR","category":"page"},{"location":"links/#YAActL.self-Tuple{}","page":"Links","title":"YAActL.self","text":"self()\n\nGet a local Link to yourself from inside an actor.\n\n\n\n\n\n","category":"method"},{"location":"links/#YAActL.USR","page":"Links","title":"YAActL.USR","text":"User channel for interacting with actors.\n\n\n\n\n\n","category":"constant"},{"location":"links/","page":"Links","title":"Links","text":"For setting up links explicitly we have the following functions.","category":"page"},{"location":"links/","page":"Links","title":"Links","text":"newLink\nLinkParams\nparallel","category":"page"},{"location":"links/#YAActL.newLink","page":"Links","title":"YAActL.newLink","text":"newLink(sz::Integer=32)\n\nCreate a link of buffer size sz to get responses from actors. Buffer sizes sz < 10 are not allowed.\n\nExample\n\njulia> response = newLink()\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"function"},{"location":"links/#YAActL.LinkParams","page":"Links","title":"YAActL.LinkParams","text":"LinkParams(size=32; taskref=nothing, spawn=false)\n\nSet the parameters for setting up an Actor. \n\nParameters\n\npid::Int: process identification,\nsize::Int: channel buffer size, must be size ≥ 10,\ntaskref::Union{Nothing, Ref{Task}}: If you need a reference to the created task,   pass a Ref{Task} object via the keyword argument taskref.\nspawn::Bool: If spawn = true, the Task created may be scheduled on another   thread in parallel, equivalent to creating a task via Threads.@spawn.\npersistent::Bool: if persistent = false, the \n\n\n\n\n\n","category":"type"},{"location":"links/#YAActL.parallel","page":"Links","title":"YAActL.parallel","text":"parallel(size=32; taskref=nothing)\n\nReturn LinkParams with spawn=true.\n\n\n\n\n\n","category":"function"},{"location":"#YAActL.jl","page":"YAActL.jl","title":"YAActL.jl","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"Yet Another Actor Library (in Julia)","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"YAActL aims to be a tiny smart actor library for parallel and distributed computing. It is in early development and uses native Julia tasks and channels to implement actors.","category":"page"},{"location":"#Quick-Intro","page":"YAActL.jl","title":"Quick Intro","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"An Actor reads a Message from a Link and passes it to a function implementing its behavior. It can change the behavior with become. To setup an actor system you need to define messages and to implement some behaviors:","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"using YAActL, Printf\n\nstruct Prt <: Message        # define a message\n    txt::String\nend\n\n# define two behaviors accepting a msg::Message as their last argument\nfunction pr(msg::Prt)\n    print(@sprintf(\"%s\\n\", msg.txt))\n    become(pr, \"Next\") # change behavior\nend\npr(info, msg::Prt) = print(@sprintf(\"%s: %s\\n\", info, msg.txt))\n\n# a behavior for doing arithmetic\nfunction calc(op::F, v::U, msg::Request) where {F<:Function,U<:Number}\n    send!(msg.lk, Response(op(v,msg.x)))\nend\n\n# start an actor with the first behavior and save the returned link\nmyactor = Actor(pr)","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"now we can interact with it:","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"julia> send!(myactor, Prt(\"My first actor\"));  # send a message to it\nMy first actor\n\njulia> send!(myactor, Prt(\"Something else\"));  # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\");   # change the behavior to another one\n\njulia> send!(myactor, Prt(\"bla bla bla\"));     # and send again a message\nNew behavior: bla bla bla","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"Our actor can also change to a completely different behavior and do some arithmetic:","category":"page"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"julia> become!(myactor, calc, +, 10);         # now become a adding machine\n\njulia> send!(myactor, Request(5, USR));       # send a request to add 5\n\njulia> take!(USR)                             # take the result\nResponse{Int64}(15)","category":"page"},{"location":"#Why-YAActl?","page":"YAActL.jl","title":"Why YAActl?","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"I could not find a suitable actor library for implementing reactive state machines in Julia. So I am writing one. Please join me to develop it.","category":"page"},{"location":"#References","page":"YAActL.jl","title":"References","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press\nVaughn Vernon: Reactive Messaging Patterns with the Actor Model, Applications and Integrations in Scala and Akka.- 2016, Pearson","category":"page"},{"location":"#Author(s)","page":"YAActL.jl","title":"Author(s)","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"Paul Bayer","category":"page"},{"location":"#License","page":"YAActL.jl","title":"License","text":"","category":"section"},{"location":"","page":"YAActL.jl","title":"YAActL.jl","text":"YAActL is licensed under the MIT License.","category":"page"},{"location":"setup/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"setup/","page":"Installation","title":"Installation","text":"YAActL\nYAActL.version","category":"page"},{"location":"setup/#YAActL","page":"Installation","title":"YAActL","text":"YAActL\n\nYet Another Actor Library (in Julia VERSION ≥ v\"1.3\").\n\nThe current stable, registered version is installed with\n\npkg> add YAActL\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/YAActL.jl\")\n\n\n\n\n\n","category":"module"},{"location":"setup/#YAActL.version","page":"Installation","title":"YAActL.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"setup/","page":"Installation","title":"Installation","text":"using YAActL\nYAActL.version","category":"page"}]
}
