var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"An actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"YAActL provides a library for messages, links (message channels), behaviors and actors which enables us to implement actor systems in Julia.","category":"page"},{"location":"usage/#Messages","page":"Usage","title":"Messages","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Messages in YAActL have a common abstract type. This enables actors to dispatch their behavior functions on message types.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Some basic message types are for setting up the type hierarchy and for controlling the actors themselves:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Message\nStop\nYAActL.Become","category":"page"},{"location":"usage/#YAActL.Message","page":"Usage","title":"YAActL.Message","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"usage/#YAActL.Stop","page":"Usage","title":"YAActL.Stop","text":"Stop(): a message causing an actor to stop.\n\n\n\n\n\n","category":"type"},{"location":"usage/#YAActL.Become","page":"Usage","title":"YAActL.Become","text":"Become(f::Function, args...; kwargs...): internal message for behavior change.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"The following message types are for executing and dispatching standard behaviors:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Request\nResponse","category":"page"},{"location":"usage/#YAActL.Request","page":"Usage","title":"YAActL.Request","text":"Request(x, u::Link): a message representing a request of x by customer u.\n\n\n\n\n\n","category":"type"},{"location":"usage/#YAActL.Response","page":"Usage","title":"YAActL.Response","text":"Response(y): a message representing a response of y to a request.\n\n\n\n\n\n","category":"type"},{"location":"usage/","page":"Usage","title":"Usage","text":"Other message types can be implemented by the user, for example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"struct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"With dispatch on message types we can easily implement state machines.","category":"page"},{"location":"usage/#Links","page":"Usage","title":"Links","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"We send messages to actors and actors can send them to others over links. In fact, an actor is only represented by its link. If we want a response from an actor, we must send it our own link together with a request message.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Link\nnewLink\nLinkParams\nparallel","category":"page"},{"location":"usage/#YAActL.Link","page":"Usage","title":"YAActL.Link","text":"A Channel{Message} type for communicating with actors.\n\nwarn: Warn\nIn actor systems we always use buffered links to avoid blocking. Responding on an unbuffered or full link causes an actor to block. Link() creates an unbuffered Channel, use Link(32) or newLink() instead!\n\nExample\n\njulia> response = Link(32)\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"type"},{"location":"usage/#YAActL.newLink","page":"Usage","title":"YAActL.newLink","text":"newLink(sz::Integer=32)\n\nCreate a link of buffer size sz to get responses from actors. Buffer sizes sz < 10 are not allowed.\n\nExample\n\njulia> response = newLink()\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.LinkParams","page":"Usage","title":"YAActL.LinkParams","text":"LinkParams(size=32; taskref=nothing, spawn=false)\n\nSet the parameters for setting up an Actor. \n\nParameters\n\nsize::Int: channel buffer size, must be size â‰¥ 10,\ntaskref::Union{Nothing, Ref{Task}}: If you need a reference to the created task,   pass a Ref{Task} object via the keyword argument taskref.\nspawn::Bool: If spawn = true, the Task created may be scheduled on another   thread in parallel, equivalent to creating a task via Threads.@spawn.\npersistent::Bool: if persistent = false, the \n\n\n\n\n\n","category":"type"},{"location":"usage/#YAActL.parallel","page":"Usage","title":"YAActL.parallel","text":"parallel(size=32; taskref=nothing)\n\nReturn LinkParams with spawn=true.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Behaviors","page":"Usage","title":"Behaviors","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"What an actor does when a message arrives, is implemented in a behavior function. A behavior function must take a Message as its last argument.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the following example we define two behaviors forward! and stack_node. There are two methods for stack_node, dispatching on Push and Pop.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Actors change their behavior with become. They also can create other actors. They can send messages to themselves and other actors.","category":"page"},{"location":"usage/#Actors","page":"Usage","title":"Actors","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Actor starts an actor on a behavior and returns a link to it.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"mystack = Actor(stack_node, StackNode(nothing, Link()))","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We pass the behavior function and its arguments (an empty StackNode but without the last msg argument!) to the actor.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Over the returned link we can send! messages to it.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Actor\nself\nsend!\nbecome\nbecome!\nstopActor\nstopActor!","category":"page"},{"location":"usage/#YAActL.Actor","page":"Usage","title":"YAActL.Actor","text":"Actor([lp::LinkParams], bhv::Function, args...; kwargs...)\n\nCreate a new actor. Start a task executing repeatedly the behavior bhv. The actor listens to messages msg sent over the returned link and executes bhv(args..., msg, kwargs) for each message. The actor stops if sent Stop().\n\nArguments\n\n[lp::LinkParams]: optional parameters for creating the actor,\nbhv::Function: function implementing the actor's behavior,\nargs...: arguments to bhv, (without msg)\nkwargs...: keyword arguments to bhv.\n\nreturn a Link to the created actor, a Channel{Message} object.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.self","page":"Usage","title":"YAActL.self","text":"self()\n\nGet a Link to yourself from inside an actor.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.send!","page":"Usage","title":"YAActL.send!","text":"send!(lk::Link, m::Message)\n\nSend a message m to an actor over a link lk.\n\n\n\n\n\nsend!(lks::Tuple{Link,Vararg{Link}}, m::M) where M<:Message\nsend!(lks::Vector{Link}, m::M) where M<:Message\n\nSend a message m to a Vector or Tuple of Links.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.become","page":"Usage","title":"YAActL.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause yourself to take on a new behavior. Called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.become!","page":"Usage","title":"YAActL.become!","text":"become!(lk::Link, bhv::Function, args...; kwargs...)\n\nCause another actor to assume a new behavior.\n\nArguments\n\nlk::Link: Link to an actor,\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.stopActor","page":"Usage","title":"YAActL.stopActor","text":"stop(): an actor terminates.\n\n\n\n\n\n","category":"function"},{"location":"usage/#YAActL.stopActor!","page":"Usage","title":"YAActL.stopActor!","text":"stop!(lk::Link): terminate an actor with link lk.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"With become actors can switch their behavior function (e.g. between different state machines) or become! causes them to switch.Thereby an actor can represent a state machine.","category":"page"},{"location":"usage/#Diagnosis","page":"Usage","title":"Diagnosis","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. You can register! an actor channel to a Vector{Link} in order to get access to the tasks.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"register!\nistaskfailed(::Link)\nistaskfailed(::Vector{Link})\ntaskstate","category":"page"},{"location":"usage/#YAActL.register!","page":"Usage","title":"YAActL.register!","text":"register!(lks::Vector{Link}, lk::Link)\n\nRegister a link lk to a vector of links lks.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Base.istaskfailed-Tuple{Channel{Message}}","page":"Usage","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"usage/#Base.istaskfailed-Tuple{Array{Channel{Message},1}}","page":"Usage","title":"Base.istaskfailed","text":"istaskfailed(lks::Vector{Link})\n\nReturns true if any task associated with a vector lks of links has failed.\n\n\n\n\n\n","category":"method"},{"location":"usage/#YAActL.taskstate","page":"Usage","title":"YAActL.taskstate","text":"taskstate(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"usage/","page":"Usage","title":"Usage","text":"[1]: See: The Actor Model on Wikipedia.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#A-Stack","page":"Examples","title":"A Stack","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is Agha's example 3.2.1. It implements a stack as a collection of actors with two operations/messages Push and Pop. A StackNode stores a content and a Link to the next Actor in the chain.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can affect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We define types for stack nodes and messages. We want our stack actor to dispatch its behavior on push and pop.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using YAActL\n\nmutable struct StackNode{T}\n    content::T\n    link::Link\nend\n\n# define the messages\nstruct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The code implementing the actor's behavior is very similar to Agha's example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Then we create the top of the stack (the receptionist). All other actors of the system are created internally each time we send a Push message. We interact only with the top of the stack:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> mystack = Actor(lk, stack_node, StackNode(nothing, Link()))\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> response = newLink()           # create a response link\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> send!(mystack, Push(1))        # push 1 on the stack\n\njulia> send!(mystack, Pop(response))  # pop it\n\njulia> take!(response)                # returns 1, 1st node now forwards messages\nResponse{Int64}(1)\n\njulia> send!(mystack, Pop(response))  # pop again\n\njulia> take!(response)                # now nothing is left\nResponse{Nothing}(nothing)\n\njulia> for i âˆˆ 1:5\n           send!(mystack, Push(i))\n       end\n\njulia> for i âˆˆ 1:5\n           send!(mystack, Pop(response))\n           println(take!(response))\n       end\nResponse{Int64}(5)\nResponse{Int64}(4)\nResponse{Int64}(3)\nResponse{Int64}(2)\nResponse{Int64}(1)","category":"page"},{"location":"examples/#A-Recursive-Factorial","page":"Examples","title":"A Recursive Factorial","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This is Agha's example 3.2.2:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Our implementation of the factorial relies on creating a customer which waits for the appropriate communication, in this case from the factorial actor itself. The factorial actor is free to concurrently process the next communication. We assume that a communication to a factorial includes a mail address to which the value of the factorial is to be sent.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For a requested factorial x  x  0 the factorial actor creates a customer actor on a parallel thread answering the request and sends itself a request with x-1 from the newly created customer. The created chain of customer actors finally answers the original request. We implement first the behaviors and then setup the factorial actor F and a response link:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using YAActL\n\nfunction rec_factorial(f::Request)\n    if f.x == 0\n        send!(f.u, Response(1))\n    else\n        c = Actor(parallel(), rec_customer, f.x, f.u) # setup parallel actors\n        send!(self(), Request(f.x - 1, c))\n    end\nend\n\nfunction rec_customer(n::Integer, u::Link, k::Response) \n    send!(u, Response(n * k.y))\n    stop()\nend\n\nF = Actor(rec_factorial)\nresp = newLink()","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can send requests to the factorial actor and take the answers from the response link:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia>  for i âˆˆ 0:5:50      # send and receive loop\n            send!(F, Request(big(i), resp))\n            println(take!(resp))\n        end\nResponse{Int64}(1)\nResponse{BigInt}(120)\nResponse{BigInt}(3628800)\nResponse{BigInt}(1307674368000)\nResponse{BigInt}(2432902008176640000)\nResponse{BigInt}(15511210043330985984000000)\nResponse{BigInt}(265252859812191058636308480000000)\nResponse{BigInt}(10333147966386144929666651337523200000000)\nResponse{BigInt}(815915283247897734345611269596115894272000000000)\nResponse{BigInt}(119622220865480194561963161495657715064383733760000000000)\nResponse{BigInt}(30414093201713378043612608166064768844377641568960512000000000000)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If we send our requests successively without waiting and then read the response link, we still get the same sequence â€“ which is a bit surprising. For sure this is not the most effective method to implement a factorial.","category":"page"},{"location":"#YAActL","page":"YAActL","title":"YAActL","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"Yet Another Actor Library (in Julia)","category":"page"},{"location":"","page":"YAActL","title":"YAActL","text":"YAActL is in early development. It uses native Julia tasks and channels to implement actors.","category":"page"},{"location":"#Installation","page":"YAActL","title":"Installation","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"] add \"https://github.com/pbayer/YAActL.jl\"","category":"page"},{"location":"#Quick-Intro","page":"YAActL","title":"Quick Intro","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"An Actor reads a Message from a Link and passes it to a function implementing his behavior. He can change his behavior with become. Basically we have to define the messages and to implement the behaviors.","category":"page"},{"location":"","page":"YAActL","title":"YAActL","text":"using YAActL, Printf\n\nstruct Print <: Message        # define a message\n    txt::String\nend\n\n# define two behaviors accepting a msg::Message as their last argument\nfunction pr(msg::Print)\n    print(@sprintf(\"%s\\n\", msg.txt))\n    become(pr, \"Next\") # change behaviour\nend\npr(info, msg::Print) = print(@sprintf(\"%s: %s\\n\", info, msg.txt))\n\n# start an actor with the first behaviour and save the returned link\nmyactor = Actor(pr)","category":"page"},{"location":"","page":"YAActL","title":"YAActL","text":"We can interact with the actor over the returned link.","category":"page"},{"location":"","page":"YAActL","title":"YAActL","text":"julia> send!(myactor, Print(\"My first actor\"));  # send a message to it\nMy first actor\n\njulia> send!(myactor, Print(\"Something else\"));  # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\");     # cause the actor to change the behavior to another one\n\njulia> send!(myactor, Print(\"bla bla bla\"));     # and send again a message\nNew behavior: bla bla bla","category":"page"},{"location":"#Why-YAActl?","page":"YAActL","title":"Why YAActl?","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"I could not find a suitable actor library for implementing reactive state machines in DiscreteEvents and StateMachines. So I am writing my own. Likewise it helps me to learn the actor concept. Please join me to develop it.","category":"page"},{"location":"#References","page":"YAActL","title":"References","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press\nVaughn Vernon: Reactive Messaging Patterns with the Actor Model, Applications and Integrations in Scala and Akka.- 2016, Pearson","category":"page"},{"location":"#Author(s)","page":"YAActL","title":"Author(s)","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"Paul Bayer","category":"page"},{"location":"#License","page":"YAActL","title":"License","text":"","category":"section"},{"location":"","page":"YAActL","title":"YAActL","text":"YAActL is licensed under the MIT License.","category":"page"}]
}
