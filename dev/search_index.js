var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#Web","page":"References","title":"Web","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"The Actor model on Wikipedia\nHewitt, Meijer and Szyperski: The Actor Model (everything you wanted to know...) on YouTube\nRobert Virding in this thread on the elixir forum suggests that there are two complementary roads to actors, a theoretical and a pragmatic one.","category":"page"},{"location":"references/#Books","page":"References","title":"Books","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Gul Agha: Actors, A Model of Concurrent Computation in Distributed Systems.- 1986, MIT Press\nJoe Armstrong: Programming Erlang, 2nd ed., Software for a Concurrent World.- 2013 Pragmatic Programmers\nPaul Butcher: Seven Concurrency Models in Seven Weeks, When Threads Unravel.- 2014 Pragmatic Programmers\nRoland Kuhn: Reactive Design Patterns.- 2017, Manning\nVaughn Vernon: Reactive Messaging Patterns with the Actor Model, Applications and Integrations in Scala and Akka.- 2016, Pearson","category":"page"},{"location":"actors/#Actors","page":"Actors","title":"Actors","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"CurrentModule = YAActL","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"An Actor is a computational entity that, in response to a message it receives, can concurrently:send a finite number of messages to other actors;\ncreate a finite number of new actors;\ndesignate the behavior to be used for the next message it receives. [1]","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL actors are Julia tasks represented by local or remote LINKs, channels over which they receive and send messages [2]. They:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"react to those messages,\nexecute user defined behavior functions when receiving certain messages,\nchange their behavior upon request,\nupdate their internal state influencing how they behave.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following provides an overview of YAActL actors:","category":"page"},{"location":"actors/#Start","page":"Actors","title":"Start","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"In the simplest case we use Actor to start an actor with a previously implemented behavior. The following code starts an actor with a stack_node behavior function and some arguments to it.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"mystack = Actor(stack_node, StackNode(nothing, Link()))","category":"page"},{"location":"actors/#Links","page":"Actors","title":"Links","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"When we started our actor, we got a link variable mystack to it. This is a local or remote channel from which actors can receive messages. We can also send messages to it.","category":"page"},{"location":"actors/#Messages","page":"Actors","title":"Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"YAActL actors operate on predefined messages, all of type Message. They process messages asynchronously. Basically there are only two functions to interact with an actor:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send!: send a message to an actor,\nreceive!: receive a message from an actor.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"A user can implement further message types. For example:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"struct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those are forwarded by the actor as last arguments to its behavior function.","category":"page"},{"location":"actors/#Behavior","page":"Actors","title":"Behavior","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors execute a behavior function when they receive a Request or another user implemented message [3]. They pass those messages as the last argument to their behavior function. Argument composition is explained in Behaviors. The actor stores the return value in its internal res variable. This can be queried from the actor with query!(lk, :res).","category":"page"},{"location":"actors/#Actor-Control","page":"Actors","title":"Actor Control","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can be controlled with the following functions:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become!: cause an actor to switch its behavior,\ncast!: cause an actor to execute its behavior function,\nexit!: cause an actor to terminate,\ninit!: tell an actor to execute a function at startup,\nset!: set an actor's dispatch mode,\nterm!: tell an actor to execute a function when it terminates.\nupdate!: update an actor's internal state,","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Those functions are wrappers to predefined messages and to send!.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Actors can also operate on themselves or rather they send messages to themselves:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"become: and actor switches its own behavior,\nself: an actor gets a link to itself,\nstop: an actor stops.","category":"page"},{"location":"actors/#Bidirectional-Messages","page":"Actors","title":"Bidirectional Messages","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"What if you want to receive a reply from an actor? Then there are two possibilities:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"send! a message to an actor and then [receive!] the Response asynchronously,\nrequest!: send a message to an actor, block and receive the result synchronously.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"The following functions do this for specific duties:","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"call! an actor to execute its behavior function and to return the result,\nexec!: execute an arbitrary function,\nquery! an actor's internal state variable.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"Note that you should not use blocking when you need to be strictly responsive.","category":"page"},{"location":"actors/#Actor-State","page":"Actors","title":"Actor State","text":"","category":"section"},{"location":"actors/","page":"Actors","title":"Actors","text":"An actor stores a behavior function and arguments to it, results of computations and more. Thus it has state and its state influences how it behaves.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"But it does not share state with its environment (only for diagnostic purposes). The API functions above are a safe way to access actor state.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[1]: See: The Actor Model on Wikipedia.","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[2]: They build on Julia's concurrency primitives  @spawn, put! and take! (to/from Channels).","category":"page"},{"location":"actors/","page":"Actors","title":"Actors","text":"[3]: Actors also execute behavior when they get the internal messages Call or Cast.","category":"page"},{"location":"examples/factorial/#factorial_example","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"","category":"section"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"This is Agha's example 3.2.2:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Our implementation of the factorial relies on creating a customer which waits for the appropriate communication, in this case from the factorial actor itself. The factorial actor is free to concurrently process the next communication. We assume that a communication to a factorial includes a mail address to which the value of the factorial is to be sent.","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"For a requested factorial x  x  0 the factorial actor creates a customer actor on a parallel thread answering the request and sends itself a request with x-1 from the newly created customer. The created chain of customer actors finally answers the original request. We implement first the behaviors and then setup the factorial actor F and a response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"using YAActL\n\nfunction rec_factorial(f::Request)\n    if f.x == 0\n        send!(f.u, Response(1))\n    else\n        c = Actor(parallel(), rec_customer, f.x, f.u) # setup parallel actors\n        send!(self(), Request(f.x - 1, c))\n    end\nend\n\nfunction rec_customer(n::Integer, u::Link, k::Response) \n    send!(u, Response(n * k.y))\n    stop()\nend\n\nF = Actor(rec_factorial)\nresp = newLink()","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"Now we can send requests to the factorial actor and take the answers from the response link:","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"julia>  for i ∈ 0:5:50      # send and receive loop\n            send!(F, Request(big(i), resp))\n            println(take!(resp))\n        end\nResponse{Int64}(1)\nResponse{BigInt}(120)\nResponse{BigInt}(3628800)\nResponse{BigInt}(1307674368000)\nResponse{BigInt}(2432902008176640000)\nResponse{BigInt}(15511210043330985984000000)\nResponse{BigInt}(265252859812191058636308480000000)\nResponse{BigInt}(10333147966386144929666651337523200000000)\nResponse{BigInt}(815915283247897734345611269596115894272000000000)\nResponse{BigInt}(119622220865480194561963161495657715064383733760000000000)\nResponse{BigInt}(30414093201713378043612608166064768844377641568960512000000000000)","category":"page"},{"location":"examples/factorial/","page":"A Recursive Factorial","title":"A Recursive Factorial","text":"If we send our requests successively without waiting and then read the response link, we still get the same sequence – which is a bit surprising. For sure this is not the most effective method to implement a factorial.","category":"page"},{"location":"behavior/#Behaviors","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"CurrentModule = YAActL","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"An actor's behavior is a ...","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"... function to express what an actor does when it processes a message. [1]","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In the following example we define two behaviors forward! and stack_node. There are two methods for stack_node, dispatching on Push and Pop.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"For controlling actor behavior YAActL uses Julia's multiple dispatch [2].","category":"page"},{"location":"behavior/#dispatch","page":"Behaviors","title":"Behavior Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"A behavior function can be implemented with different methods. Then the methods are dispatched ...","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"based on the number of arguments given, and on the types of all of the function's arguments [3].","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"YAActL actors pass the incoming message as last argument to the behavior function.   ","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Our behavior function call is stack_node(sn, msg).\nAfter its creation as Actor(stack_node, sn) the actor has only the first argument sn to the behavior.\nWith a message msg it gets the second argument and calls the behavior as stack_node(sn, msg).\nDepending on whether the incoming message is a Pop or a Push one of the two implemented methods is dispatched.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"If the actor tries to pass another message to stacknode, it will fail with an ArgumentError since only two methods are implemented.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"You can implement an epsilon default method – if you mind – returning nothing on every other Message. Then the actor will do nothing with an unknown message and not fail.","category":"page"},{"location":"behavior/#composition","page":"Behaviors","title":"Argument Composition","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"YAActL actors have two modes to compose the arguments to the behavior function and to use its returned value:","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Dispatch","category":"page"},{"location":"behavior/#YAActL.Dispatch","page":"Behaviors","title":"YAActL.Dispatch","text":"Dispatch\n\nDepending on its Dispatch mode an actor composes the arguments  to the behavior function:\n\nfull: from the Become args... and the msg.x....   This is the default dispatch mode.\nstate: from the actor state and the msg.x.... In this case the    actor updates its state with the result of the behavior   function. The result is saved in a Tuple. \n\n\n\n\n\n","category":"type"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"You can set the dispatch mode with set!.","category":"page"},{"location":"behavior/#Full-Dispatch","page":"Behaviors","title":"Full Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Above we used full dispatch. With Actor(stack_node, sn) the actor got sn as the first argument and can use that to represent state. If sn is mutable, a behavior function can even change its content. When a message msg arrives, the actor takes it as the second argument and composes them to execute the behavior.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The YAActL API allows arbitrary arguments to a behavior function. To install a predefined behavior function bhv and to deliver the first part of its arguments args1... we have","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"act = Actor(bhv, args1...) or\nbecome!(act, bhv, args1...).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The second part args2... gets delivered with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"call!(act, args2...) or\ncast!(act, args2...) or\nsend!(act, msg).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The actor then calls","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"bhv((args1..., args2...)...) or\nbhv((args1..., msg)...) respectively. ","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Empty arguments args1... or args2... are allowed as long as their composition can be used to dispatch the behavior function bhv.","category":"page"},{"location":"behavior/#State-Dispatch","page":"Behaviors","title":"State Dispatch","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In state dispatch an actor uses its internal state sta as first argument to the behavior function. On a message msg it calls the behavior as bhv(sta, msg) and saves the returned value in its internal state variable sta. Thus it operates as a finite-state machine. This is a more functional approach.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"A behavior bhv is installed without arguments[4] as","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"act = Actor(bhv) or\nbecome!(act, bhv).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Actor state sta can be set with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"init!(act, args1...) and\nupdate!(act, args1...).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The second part args2... gets delivered with","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"call!(act, args2...) or\ncast!(act, args2...) or\nsend!(act, msg).","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"and the actor calls","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"bhv((sta..., args2...)...) or\nbhv((sta..., msg)...) respectively","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"and updates sta with the returned value y. At the next call the behavior bhv gets dispatched with the updated status and the new message.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"note: Update occurs only if the behavior returns something.\nThe actor updates sta only if its behavior function returns something rather than nothing. If you want your behavior to avoid updating sta, let it return nothing. ","category":"page"},{"location":"behavior/#Keyword-Arguments","page":"Behaviors","title":"Keyword Arguments","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"In both modes an actor passes keyword arguments kwargs... to the behavior function. Those are not dispatched on but they too represent state and therefore can change the function result.","category":"page"},{"location":"behavior/#Control-of-Actor-Behavior","page":"Behaviors","title":"Control of Actor Behavior","text":"","category":"section"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"The described mechanisms allow a fine-grained control of an actor's behavior:","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"Set an actor's behavior function at startup or by become!.\nControl the dynamic dispatch of implemented behavior methods with\nthe actor's dispatch mode,\nthe first arguments delivered \neither with the behavior function in full dispatch,\nor by setting the actor state in state dispatch,\nthe second arguments delivered with the incoming message.\nControl the outcome of the dispatched function or method by setting the values of arguments and keyword arguments[5].","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"This allows actors to use Julia's full expressiveness with functions and methods.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[1]: see the Actor Model on Wikipedia.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[2]: see also JuliaCon 2019 | The Unreasonable Effectiveness of Multiple Dispatch | Stefan Karpinski.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[3]: from Methods in the Julia manual.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[4]: arguments arg1... to the behavior function are simply ignored in state dispatch.","category":"page"},{"location":"behavior/","page":"Behaviors","title":"Behaviors","text":"[5]: you can also dispatch on values by using Val","category":"page"},{"location":"messages/#Messages","page":"Messages","title":"Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"CurrentModule = YAActL","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages to YAActL actors have Message as a common abstract type. Only three predefined messages are exported:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Response: response message type from actor to any synchronous message (requiring a response),\nRequest: predefined message type for implementing requests to actors.\nTimeout: answer of receive! when a timeout occurs.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Messages other than the predefined ones can be implemented by a user.","category":"page"},{"location":"messages/#Functions-and-Arguments","page":"Messages","title":"Functions and Arguments","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"There are two types needed for transmitting functions and function arguments to actors with messages:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Func\nArgs","category":"page"},{"location":"messages/#YAActL.Func","page":"Messages","title":"YAActL.Func","text":"Func(f, args...; kwargs...)\n\nA structure for passing a function f and its arguments to an actor.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Args","page":"Messages","title":"YAActL.Args","text":"Args(args...; kwargs...)\n\nA structure for updating arguments to an actor's behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#Internal-Messages","page":"Messages","title":"Internal Messages","text":"","category":"section"},{"location":"messages/","page":"Messages","title":"Messages","text":"Actors recognize and react to the following predefined internal messages:","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"Become\nCall\nCast\nDiag\nExec\nInit\nQuery\nStop\nTerm\nUpdate","category":"page"},{"location":"messages/#YAActL.Become","page":"Messages","title":"YAActL.Become","text":"Become(x::Func)\n\nAn asynchronous Message to an actor to change its  behavior.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Call","page":"Messages","title":"YAActL.Call","text":"Call(arg, from::LINK)\n\nA synchronous Message to an actor to execute its  behavior with arg... and to send the result as a Response  message to from.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Cast","page":"Messages","title":"YAActL.Cast","text":"Cast(arg)\n\nAn asynchronous Message to an actor to execute  its behavior with arg... without sending a response.\n\nIf the actor is set to state dispatch, it updates its internal  state with the result. \n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Diag","page":"Messages","title":"YAActL.Diag","text":"Diag(from::LINK)\n\nA synchronous Message to an actor to send a  Response message with its internal _ACT variable to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Exec","page":"Messages","title":"YAActL.Exec","text":"Exec(func::Func, from::LINK)\n\nA synchronous Message to an actor to execute func and to send a Response message with the return value to from.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Init","page":"Messages","title":"YAActL.Init","text":"Init(f::Func)\n\nA Message to an actor to execute the given Func and to register it in the _ACT variable.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Query","page":"Messages","title":"YAActL.Query","text":"Query(s::Symbol, from::LINK)\n\nA Message to an actor to send a  Response message with one of its internal state  variables s to from.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Stop","page":"Messages","title":"YAActL.Stop","text":"Stop(code=0)\n\nA Message causing an actor to stop with an exit code. If present, it calls its term! function with code as last argument.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Term","page":"Messages","title":"YAActL.Term","text":"Term(x::Func)\n\nA Message to an actor to save the given Func  and to execute it upon termination.\n\n\n\n\n\n","category":"type"},{"location":"messages/#YAActL.Update","page":"Messages","title":"YAActL.Update","text":"Update(s::Symbol, x)\n\nAn asynchronous Message to an actor to update its  internal state s to x.\n\ns::Symbol can be one of :sta, :dsp, :arg, :lnk.\n\n\n\n\n\n","category":"type"},{"location":"messages/","page":"Messages","title":"Messages","text":"Those messages are interfaced by the functions in the YAActL API.","category":"page"},{"location":"messages/","page":"Messages","title":"Messages","text":"If an actor receives another subtype of Message, it calls its behavior function with it as last argument.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A YAActL actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"is a task running on a thread or a remote node which\nreceives messages over a channel and with it\ndispatches a behavior function or one of of its methods.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"using YAActL, Printf\n\n# define two functions for printing a message\nfunction pr(msg)\n    print(@sprintf(\"%s\\n\", msg))\n    become(pr, \"Next\") # change behavior\nend\npr(info, msg) = print(@sprintf(\"%s: %s\\n\", info, msg))\n\n# a function for doing arithmetic\ncalc(op::F, x, y) where F<:Function = op(x, y)\n\n# start an actor with the first behavior\nmyactor = Actor(pr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Now we can interact with it:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"My first actor\")     # send a message to it\nMy first actor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor has executed its behavior function pr with the message as argument. You may have noticed above that pr(msg) causes the actor to change its behavior to pr(\"Next:\", msg). Now we send it something else:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> cast!(myactor, \"Something else\")     # send again a message\nNext: Something else\n\njulia> become!(myactor, pr, \"New behavior\") # change the behavior to another one\n\njulia> cast!(myactor, \"bla bla bla\")        # and send again a message\nNew behavior: bla bla bla","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Our actor can also change to a completely different behavior and do some arithmetic:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"julia> become!(myactor, calc, +, 10);       # now become a machine for adding to 10\n\njulia> call!(myactor, 5)                    # send a request to add 5 to it and to return the result\n15\n\njulia> become!(myactor, ^);                 # become an exponentiation machine\n\njulia> call!(myactor, 123, 456)             # try it\n2409344748064316129","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Actors thus can represent different and changing behaviors of real world or computational objects.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"If we implement and start multiple actors interacting with each other, we get an actor system.","category":"page"},{"location":"examples/stack/#stack_example","page":"A Stack","title":"A Stack","text":"","category":"section"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"This is Agha's example 3.2.1. It implements a stack as a collection of actors with two operations/messages Push and Pop. A StackNode stores a content and a Link to the next Actor in the chain.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"The top of the stack is the only receptionist in the stack system and was the only actor of the stack system created externally. It is created with a NIL content which is assumed to be the bottom of the stack marker. Notice that no mail address of a stack node is ever communicated by any node to an external actor. Therefore no actor outside the configuration defined above can affect any of the actors inside the stack except by sending the receptionist a communication. When a pop operation is done, the actor on top of the stack simply becomes a forwarder to the next actor in the link. This means that all communications received by the top of the stack are now forwarded to the next element.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"We define types for stack nodes and messages. We want our stack actor to dispatch its behavior on push and pop.","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"using YAActL\n\nmutable struct StackNode{T}\n    content::T\n    link::Link\nend\n\n# define the messages\nstruct Pop <: Message\n    customer::Link\nend\n\nstruct Push{T} <: Message\n    content::T\nend","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"The code implementing the actor's behavior is very similar to Agha's example:","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"forward!(lk::L, msg::M) where {L<:Link, M<:Message} = send!(lk, msg)\n\nfunction stack_node(sn::StackNode, msg::Pop)\n    isnothing(sn.content) || become(forward!, sn.link)\n    send!(msg.customer, Response(sn.content))\nend\n\nfunction stack_node(sn::StackNode, msg::Push)\n    P = Actor(stack_node, sn)\n    become(stack_node, StackNode(msg.content, P))\nend","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"Then we create the top of the stack (the receptionist). All other actors of the system are created internally each time we send a Push message. We interact only with the top of the stack:","category":"page"},{"location":"examples/stack/","page":"A Stack","title":"A Stack","text":"julia> mystack = Actor(stack_node, StackNode(nothing, Link()))\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> response = newLink()           # create a response link\nChannel{Message}(sz_max:32,sz_curr:0)\n\njulia> send!(mystack, Push(1))        # push 1 on the stack\n\njulia> send!(mystack, Pop(response))  # pop it\n\njulia> take!(response)                # returns 1, 1st node now forwards messages\nResponse{Int64}(1)\n\njulia> send!(mystack, Pop(response))  # pop again\n\njulia> take!(response)                # now nothing is left\nResponse{Nothing}(nothing)\n\njulia> for i ∈ 1:5\n           send!(mystack, Push(i))\n       end\n\njulia> for i ∈ 1:5\n           send!(mystack, Pop(response))\n           println(take!(response))\n       end\nResponse{Int64}(5)\nResponse{Int64}(4)\nResponse{Int64}(3)\nResponse{Int64}(2)\nResponse{Int64}(1)","category":"page"},{"location":"diagnosis/#Diagnosis","page":"Diagnosis","title":"Diagnosis","text":"","category":"section"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"CurrentModule = YAActL","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"In order to develop actor programs, it is useful to have access to the actor tasks and eventually to their stack traces. You can register! an actor channel to a Vector{Link} in order to get access to the tasks.","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"register!\nistaskfailed(::Link)\nistaskfailed(::Vector{Link})\ninfo","category":"page"},{"location":"diagnosis/#YAActL.register!","page":"Diagnosis","title":"YAActL.register!","text":"register!(lks::Vector{Link}, lk::Link)\n\nRegister a link lk to a vector of links lks.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Channel{Message}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lk::Link)\n\nReturns true if a task associated with lk has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#Base.istaskfailed-Tuple{Array{Channel{Message},1}}","page":"Diagnosis","title":"Base.istaskfailed","text":"istaskfailed(lks::Vector{Link})\n\nReturns true if any task associated with a vector lks of links has failed.\n\n\n\n\n\n","category":"method"},{"location":"diagnosis/#YAActL.info","page":"Diagnosis","title":"YAActL.info","text":"info(lk::Link)\n\nReturn the state (eventually the stacktrace) of a task associated  with lk.\n\n\n\n\n\n","category":"function"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"For diagnostic purposes it is possible to get access to the actor's ACT variable:","category":"page"},{"location":"diagnosis/","page":"Diagnosis","title":"Diagnosis","text":"diag!","category":"page"},{"location":"diagnosis/#YAActL.diag!","page":"Diagnosis","title":"YAActL.diag!","text":"diag!(lk::LINK)\n\nReturn the internal _ACT variable of the lk actor. This is only for diagnosis and testing.\n\n\n\n\n\n","category":"function"},{"location":"internals/#state","page":"Actor State","title":"Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"CurrentModule = YAActL","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"YAActL follows Julia's philosophy in giving the user responsibility for access to internals and implementing correct programs:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"You are entirely responsible for ensuring that your program is data-race free, and nothing promised here can be assumed if you do not observe that requirement. The observed results may be highly unintuitive. [1]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"When using multi-threading we have to be careful when using functions that are not pure as we might get a wrong answer. [2]","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Since concurrency is the overarching theme of actor programming and behavior functions must access data to do their job, data-race freedom is a major concern in working with actors. As a ground rule actors don't share state.","category":"page"},{"location":"internals/#Internal-State","page":"Actor State","title":"Internal State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Actors have an internal mutable state variable: ","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"_ACT","category":"page"},{"location":"internals/#YAActL._ACT","page":"Actor State","title":"YAActL._ACT","text":"_ACT(lk::LINK)\n\nInternal actor status variable.\n\nFields\n\ndsp::Dispatch: dispatch mode,\nsta::Tuple: the actor's status variable,\nres::Tuple: the result of the last behavior execution,\nbhv::Func : the behavior function and its internal arguments,\ninit::Func: the init function and its arguments,\nterm::Func: the terminate function and its arguments,\nlink::LINK: the actors (local or remote) link.\n\nsee also: Dispatch, Func, LINK\n\n\n\n\n\n","category":"type"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Functions executed by an actor can access their actor's internal ACT variable via task_local_storage(\"ACT\").  Normally this is not needed.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"We must express two important concerns regarding actor state:","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"note: Actor state is multifaceted!\nActor state is not a single value but includes behavior functions, arguments and an explicit mutable state variable, which is used for state Dispatch or for representing agents.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"warning: Sharing state can cause critical race conditions!\nYou must be careful not to share any of the state variables between actors in order to avoid critical race conditions.","category":"page"},{"location":"internals/#Create-Private-Actor-State","page":"Actor State","title":"Create Private Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"The returned value of the init! function is saved as an actors state sta. It is a good practice to have an init function to create a private actor state with defined initial parameters.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Be careful to update! the actor's state since it overwrites it. Don't update it with a shared variable.","category":"page"},{"location":"internals/#Update-Actor-State","page":"Actor State","title":"Update Actor State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Only the actor itself is allowed to update its state in a strictly sequential manner by processing message after message.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Other actors or users can cause an actor to update its state by sending it a message, which is done implicitly by using the API functions.","category":"page"},{"location":"internals/#Behavior-Function-Arguments","page":"Actor State","title":"Behavior Function Arguments","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Julia functions accept mutable types as parameters and  can change their values. If your behavior functions get mutable types as parameters, you must ensure that","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"either you don't share those variables between actors\nor you don't change them by using only pure functions as behavior.","category":"page"},{"location":"internals/#Global-State","page":"Actor State","title":"Global State","text":"","category":"section"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"Race conditions can happen if actors in parallel use or modify global variables. The best advice is not to use global variables or at least not to share them between actors.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"If for some reason you want to use global variables and share them between actors, you must use the lock pattern or atomic operations described in the Julia manual. But both approaches block an actor until it succeeds to access the variable.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[1]: see: Data-race freedom in the Julia manual.","category":"page"},{"location":"internals/","page":"Actor State","title":"Actor State","text":"[2]: see: Side effects and mutable function arguments in the Julia manual.","category":"page"},{"location":"api/#Actor-API","page":"Actor API","title":"Actor API","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"CurrentModule = YAActL","category":"page"},{"location":"api/#Installation","page":"Actor API","title":"Installation","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"YAActL\nYAActL.version","category":"page"},{"location":"api/#YAActL.YAActL","page":"Actor API","title":"YAActL.YAActL","text":"YAActL\n\nYet Another Actor Library (in Julia VERSION ≥ v\"1.3\").\n\nThe current stable, registered version is installed with\n\npkg> add YAActL\n\nThe development version is installed with:\n\npkg> add(\"https://github.com/pbayer/YAActL.jl\")\n\n\n\n\n\n","category":"module"},{"location":"api/#YAActL.version","page":"Actor API","title":"YAActL.version","text":"Gives the package version.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"using YAActL\nYAActL.version","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions provide a user interface to actors:","category":"page"},{"location":"api/#Start","page":"Actor API","title":"Start","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actor","category":"page"},{"location":"api/#YAActL.Actor","page":"Actor API","title":"YAActL.Actor","text":"Actor([lp::LinkParams], bhv::Function, args1...; kwargs...)\nActor(pid::Int, bhv::Function, args1...; kwargs...)\n\nCreate a new actor. Start a task listening to messages msg  sent over the returned link and executing bhv(args1..., msg; kwargs...)  for each message. The actor stops if sent Stop().\n\nArguments\n\n[lp::LinkParams]: parameters for creating the actor,\npid::Int: process pid to create the actor on, this can    also be given with lp,\nbhv: a function implementing the actor's behavior,\nargs1...: first arguments to bhv (without possible msg arguments),\nkwargs...: keyword arguments to bhv.\n\nReturns\n\na Link to a locally created actor or \nan RLink to a remote actor.\n\nsee also: LinkParams\n\n\n\n\n\n","category":"function"},{"location":"api/#links","page":"Actor API","title":"Links","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"An actor is only represented by its link which it returns upon creation:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Link\nRLink\nLINK","category":"page"},{"location":"api/#YAActL.Link","page":"Actor API","title":"YAActL.Link","text":"A Channel{Message} type for communicating with local actors.\n\nwarning: Use buffered channels!\nIn actor systems we use buffered links to avoid blocking. Responding on an unbuffered or full link causes an actor to block. Link() creates an unbuffered Channel. Use Link(32) or newLink() instead!\n\nExample\n\njulia> response = Link(32)\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.RLink","page":"Actor API","title":"YAActL.RLink","text":"A RemoteChannel{Link} type for communicating with remote actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.LINK","page":"Actor API","title":"YAActL.LINK","text":"A Union{Link, RLink} type including local and remote links. \n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors correspond with other actors over links. There is a default link for users to communicate with actors.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"USR","category":"page"},{"location":"api/#YAActL.USR","page":"Actor API","title":"YAActL.USR","text":"User remote channel for interacting with actors.\n\n\n\n\n\n","category":"constant"},{"location":"api/","page":"Actor API","title":"Actor API","text":"For setting up links explicitly we have the following functions.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"newLink\nLinkParams\nparallel","category":"page"},{"location":"api/#YAActL.newLink","page":"Actor API","title":"YAActL.newLink","text":"newLink(sz::Integer=32)\n\nCreate a link of buffer size sz to get responses from actors. Buffer sizes sz < 10 are not allowed.\n\nExample\n\njulia> response = newLink()\nChannel{Message}(sz_max:32,sz_curr:0)\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.LinkParams","page":"Actor API","title":"YAActL.LinkParams","text":"LinkParams(pid=myid(), size=32; taskref=nothing, spawn=false)\n\nParameters for setting up an Actor. \n\npid::Int: process identification,\nsize::Int: channel buffer size, must be size ≥ 10,\ntaskref::Union{Nothing, Ref{Task}}: If you need a reference to the created task,   pass a Ref{Task} object via the keyword argument taskref.\nspawn::Bool: If spawn = true, the Task created may be scheduled on another   thread in parallel, equivalent to creating a task via Threads.@spawn.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.parallel","page":"Actor API","title":"YAActL.parallel","text":"parallel(size=32; taskref=nothing)\n\nReturn LinkParams with spawn=true.\n\nExample\n\njulia> using YAActL, .Threads\n\njulia> myactor = Actor(parallel(), threadid);\n\njulia> call!(myactor)\n2\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"We send messages to actors and they can send them to others over links.","category":"page"},{"location":"api/#Messages","page":"Actor API","title":"Messages","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Messages in YAActL have a common abstract type. Only a few predefined messages are exported:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Message\nResponse\nRequest\nTimeout","category":"page"},{"location":"api/#YAActL.Message","page":"Actor API","title":"YAActL.Message","text":"Abstract type for messages to actors.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Response","page":"Actor API","title":"YAActL.Response","text":"Response(y, from::LINK=self())\n\nA Message representing a response to requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Request","page":"Actor API","title":"YAActL.Request","text":"Request(x, from::LINK)\n\nA generic Message for user requests.\n\n\n\n\n\n","category":"type"},{"location":"api/#YAActL.Timeout","page":"Actor API","title":"YAActL.Timeout","text":"Timeout()\n\nA return value to signal that a timeout has occurred.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Actors operate with internal messages. Further messages can be implemented by a user. If an actor receives a message other than an internal one, it passes the message as last argument to the behavior function.","category":"page"},{"location":"api/#Send-and-Receive","page":"Actor API","title":"Send and Receive","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Messages are sent and received using the following basic functions:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"send!\nreceive!","category":"page"},{"location":"api/#YAActL.send!","page":"Actor API","title":"YAActL.send!","text":"send!(lk::LINK, m::Message)\n\nSend a message m to an actor over a LINK lk.\n\n\n\n\n\nsend!(lks::Tuple{LINK,Vararg{LINK}}, m::M) where M<:Message\nsend!(lks::Vector{LINK}, m::M) where M<:Message\n\nSend a message m to a Vector or Tuple of LINKs.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.receive!","page":"Actor API","title":"YAActL.receive!","text":"receive!(lk; timeout=5.0)\nreceive!(lk, from; timeout=5.0)\nreceive!(lk, Msg; timeout=5.0)\nreceive!(lk, Msg, from; timeout=5.0)\n\nReceive a message over a link lk.\n\nIf Msg or from are provided, receive! returns only a  matching message. Other messages in lk are restored to it in their previous order.\n\nParameters\n\nlk::LINK: local or remote link over which the message is received,\nMsg::Type{<:Message}: Message type,\nfrom::LINK: local or remote link of sender. If from is   provided, only messages with a from field can be matched.\ntimeout::Real=5.0: maximum waiting time in seconds.\nIf timeout==0, lk is scanned only for existing messages.\nSet timeout=Inf if you don't want to timeout. \n\nReturns\n\nreceived message or Timeout().\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Control","page":"Actor API","title":"Actor Control","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions control actor behavior and state by sending implicit messages. Actors don't send a Response to those.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"become!\ncast!\nexit!\nset!\nupdate!","category":"page"},{"location":"api/#YAActL.become!","page":"Actor API","title":"YAActL.become!","text":"become!(lk::LINK, bhv::Function, args1...; kwargs...)\n\nCause an actor to change behavior.\n\nArguments\n\nlk::Link: Link to an actor,\nbhv: function implementing the new behavior,\nargs1...: first arguments to bhv (without a possible msg argument),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.cast!","page":"Actor API","title":"YAActL.cast!","text":"cast!(lk::LINK, args2...)\n\nCast a message to the lk actor to execute its behavior  function with args2... without sending a response. \n\nNote: you can prompt the returned value with query!.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.exit!","page":"Actor API","title":"YAActL.exit!","text":"exit!(lk::LINK, code=0)\n\nTell an actor lk to exit. If it has a term  function, it calls it with code as last argument. \n\nnote: This behavior is not yet fully implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.set!","page":"Actor API","title":"YAActL.set!","text":"set!(lk::LINK, dsp::Dispatch)\n\nSet the lk actor's Dispatch to dsp.\n\nExample\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.update!","page":"Actor API","title":"YAActL.update!","text":"update!(lk::LK, args...; s::Symbol=:sta)\n\nUpdate the lk actor's internal state s with args....\n\nArguments\n\nargs...: arguments to update the choosen state with,\ns::Symbol: can be one of :sta, :dsp, :arg, :lnk.\n\nNote: If you want to update the stored arguments to the  behavior function with s=:arg, you must pass an Args  argument. If Args has keyword arguments, they are merged  with existing keyword arguments to the behavior function.\n\nExamples\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"If a behavior function wants to control its own actor, it can use the following functions:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"become\nself\nstop","category":"page"},{"location":"api/#YAActL.become","page":"Actor API","title":"YAActL.become","text":"become(bhv::Function, args...; kwargs...)\n\nCause your actor to take on a new behavior. This can only be called from inside an actor/behavior.\n\nArguments\n\nbhv::Function: function implementing the new behavior,\nargs...: arguments to bhv (without msg),\nkwargs...: keyword arguments to bhv.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.self","page":"Actor API","title":"YAActL.self","text":"self()\n\nGet the LINK of your actor.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.stop","page":"Actor API","title":"YAActL.stop","text":"stop(code=0)\n\nCause your actor to exit with code.\n\n\n\n\n\n","category":"function"},{"location":"api/#Bidirectional-Messaging","page":"Actor API","title":"Bidirectional Messaging","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Some messages to actors cause them to send a Response [1]. The exchange of messages may be carried out asynchronously, or may use a synchronous \"rendezvous\" style in which the sender blocks until the message is received.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"YAActL has a primitive for synchronous communication:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"request!","category":"page"},{"location":"api/#YAActL.request!","page":"Actor API","title":"YAActL.request!","text":"request!(lk::LINK, msg::Message; full=false, timeout::Real=5.0)\nrequest!(lk::LINK, Msg::Type{<:Message}, args...; kwargs...)\n\nSend a message to an actor, block, receive and return the result.\n\nArguments\n\nlk::LINK: actor link,\nmsg::Message: a message,\nMsg::Type{<:Message}: a message type,\nargs...: optional arguments to Msg, \nfull: if true return the full Response message.\ntimeout::Real=5.0: timeout in seconds after which a    Timeout is returned,\nkwargs...: full or timeout.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"The following functions support both messaging styles:","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"Send a message with an explicit from-link to an actor and it will respond to it. Then you can asynchronously receive! the response.\nSend a message with an implicit link to an actor, block, wait for the response and return it.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"call!\nexec!\nquery!","category":"page"},{"location":"api/#YAActL.call!","page":"Actor API","title":"YAActL.call!","text":"call!(lk::LINK, from::LINK, args2...)\ncall!(lk::LINK, args2...; timeout::Real=5.0)\n\nCall the lk actor to execute its behavior function with  args2... and to send a Response with the result  to from. \n\nIf from is omitted, call! blocks and returns the result.  In that case there is a timeout.\n\nExamples\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.exec!","page":"Actor API","title":"YAActL.exec!","text":"exec!(lk::LINK, from::LINK, f::Function, args...; kwargs...)\nexec!(lk::LINK, from::LINK, fu::Func)\nexec!(lk::LINK, fu::Func; timeout::Real=5.0)\n\nAsk an actor to execute an arbitrary function and to  send the returned value as Response.\n\nArguments\n\nlk::LINK: link to the actor,\nfrom::LINK: the link a Response should be sent to.   If from is ommitted, exec! blocks, waits and returns    the result. In that case there is a timeout.\nf::Function, args...; kwargs... or\nfu::Func: function arguments,\ntimeout::Real=5.0: timeout in seconds. Set timeout=Inf    if you don't want a timeout.\n\nExamples\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.query!","page":"Actor API","title":"YAActL.query!","text":"query!(lk::LINK, from::LINK, s::Symbol)\nquery!(lk::LINK, s::Symbol; timeout::Real=5.0)\n\nAsk the lk actor to send a Response message to from with an internal state variable s. \n\nIf from is omitted, query! blocks and returns the response. In that case there is a timeout.\n\ns::Symbol can be one of :sta, :res, :bhv, :dsp.\n\nExamples\n\n\n\n\n\n\n\n","category":"function"},{"location":"api/#Actor-Supervision","page":"Actor API","title":"Actor Supervision","text":"","category":"section"},{"location":"api/","page":"Actor API","title":"Actor API","text":"This is not yet implemented.","category":"page"},{"location":"api/","page":"Actor API","title":"Actor API","text":"init!\nterm!","category":"page"},{"location":"api/#YAActL.init!","page":"Actor API","title":"YAActL.init!","text":"init!(lk::LINK, f::Function, args...; kwargs...)\n\nTell an actor lk to save the function f with the given  arguments as an init function, to execute it  and to save the returned value as state sta  variable.\n\nThe init function will be called at actor restart.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/#YAActL.term!","page":"Actor API","title":"YAActL.term!","text":"term!(lk::LINK, f::Function, args1...; kwargs...)\n\nTell an actor lk to execute a function f with the given arguments when it terminates. f must accept a code=0  as last argument. This is added by the actor to args1...  when it exit!s.\n\nnote: This behavior is not yet implemented!\nIt is needed for supervision.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Actor API","title":"Actor API","text":"[1]: bidirectional messages are Call, Get, Exec and Query.","category":"page"},{"location":"examples/state-machines/#State-Machines","page":"State Machines","title":"State Machines","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"There are various ways to implement state machines with actors. The following examples show some approaches and don't propose actual implementations.","category":"page"},{"location":"examples/state-machines/#A-DFA","page":"State Machines","title":"A DFA","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"One of the simplest ways to implement a state machine behavior is to implement a behavior function with appropriate transition methods for each state-event combination.","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"We take a deterministic finite automaton, A = (sqprabcδsr) with the following state-transition table:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"| | inputs  | 'a' | 'b' | 'c' | |–:|–––-:|:––-:|:––-:|:––-:| |initial state|   -> s  |  s  |  q  |  s | | |      q  |  p  |  r  |  r | | |      p  |  p  |  q  |  p | |accepting state|    * r  |  r  |  r  |  r |","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"We can implement that directly: ","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"using YAActL\n\ns(::Val{'b'}) = become(q)  # implement behaviors\ns(x) = nothing\nq(::Val{'a'}) = become(p)\nq(::Val{'b'}) = become(r)\nq(::Val{'c'}) = become(r)\nq(x) = nothing\np(::Val{'b'}) = become(q)\np(x) = nothing\nr(x) = nothing","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"We dispatch on values and use default transitions doing nothing. We start an actor and use a small check function to parse input strings:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"mydfa = Actor(s)\n\nfunction check(lk::Link, str::String)\n    become!(lk, s)         # start behavior\n    foreach(str) do c\n        cast!(lk, Val(c))  # send all chars\n    end\n    get!(lk, :bhv) == r    # check the final behavior\nend","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Then we can check which strings get accepted:","category":"page"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"julia> check(mydfa, \"baab\")\nfalse\n\njulia> check(mydfa, \"baabc\")\ntrue\n\njulia> check(mydfa, \"babaccabb\")\ntrue","category":"page"},{"location":"examples/state-machines/#A-NFA","page":"State Machines","title":"A NFA","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Non-deterministic finite automata can have more complex states, and more than one transition can happen at an input event.","category":"page"},{"location":"examples/state-machines/#A-Fibonacci-Server","page":"State Machines","title":"A Fibonacci Server","text":"","category":"section"},{"location":"examples/state-machines/","page":"State Machines","title":"State Machines","text":"Servers often store data and provide it with some additional computation. One classic example of that is a Fibonacci server:","category":"page"},{"location":"examples/pmap/#Parallel-Map","page":"Parallel Map","title":"Parallel Map","text":"","category":"section"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"Here we compare five executions of comp, a \"heavy\" computation taking 2 seconds:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"using YAActL, .Threads, Distributed\n\nfunction comp(i)  # a \"heavy\" computation\n    sleep(2)\n    return (id=i, thrd=threadid())\nend","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"We can check how long it takes sequentially:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> @time map(comp, 1:5)  # sequential\n 10.024817 seconds (36 allocations: 1.234 KiB)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 1, thrd = 1)\n (id = 2, thrd = 1)\n (id = 3, thrd = 1)\n (id = 4, thrd = 1)\n (id = 5, thrd = 1)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with Julia's Threads:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> @time begin\n            t = map(x->(Threads.@spawn comp(x)), 1:5)\n            map(fetch, t)\n       end\n  2.074831 seconds (150.55 k allocations: 8.045 MiB)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 1, thrd = 2)\n (id = 2, thrd = 3)\n (id = 3, thrd = 5)\n (id = 4, thrd = 4)\n (id = 5, thrd = 6)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with YAActL (we get the results in the USR channel):","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> A = map(i->Actor(parallel(), comp, i), 1:5); # start actors\n\njulia> @time begin\n           foreach(a->call!(a, USR), A)\n           map(x->receive!(USR).y, 1:5)\n       end\n  2.042264 seconds (83.46 k allocations: 4.448 MiB, 0.53% gc time)\n5-element Array{NamedTuple{(:id, :thrd),Tuple{Int64,Int64}},1}:\n (id = 2, thrd = 3)\n (id = 5, thrd = 6)\n (id = 4, thrd = 4)\n (id = 3, thrd = 2)\n (id = 1, thrd = 5)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"now with Distributed:","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"julia> addprocs(4);   # add processes \n\njulia> @everywhere function comp(i)  # a \"heavy\" computation\n           sleep(2)\n           return (id=i, prc=myid())\n       end\n\njulia> @time begin\n            f = map(i->(@spawnat i comp(i)), 1:5)\n            map(fetch, f)\n       end\n  2.252625 seconds (185.30 k allocations: 9.740 MiB, 0.38% gc time)\n5-element Array{NamedTuple{(:id, :prc),Tuple{Int64,Int64}},1}:\n (id = 1, prc = 1)\n (id = 2, prc = 2)\n (id = 3, prc = 3)\n (id = 4, prc = 4)\n (id = 5, prc = 5)","category":"page"},{"location":"examples/pmap/","page":"Parallel Map","title":"Parallel Map","text":"YAActL actors and Distributed processes are persistent objects. Therefore we must allocate them before we do computations with them. If we work with remote actors on other processes or nodes, we have to ensure as in Distributed that the code is available on each node.","category":"page"},{"location":"patterns/#Actor-Patterns","page":"Actor Patterns","title":"Actor Patterns","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"Here we describe some things we can do with actors:","category":"page"},{"location":"patterns/#State-Machines","page":"Actor Patterns","title":"State Machines","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"Actors can be used to store, search, filter, compose, calculate ... concurrently on a computer or in a network. All those different activities can be seen generally as state machines.","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"State machines have state and react to events. In that basic sense actors are state machines and are particularly suited to represent them. YAActL actors have been designed to support various approaches to implement state machines.","category":"page"},{"location":"patterns/#Parallel-Computation","page":"Actor Patterns","title":"Parallel Computation","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"... actors provide no direct support for parallelism. ... And because actors do not share state and can only communicate through message passing, they are not a suitable choice if you need fine-grained parallelism. [1]","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"As with Julia's built-in functionality you can easily parallelize heavy computations with actors. This is shown in the parallel map example.","category":"page"},{"location":"patterns/#Building-Systems","page":"Actor Patterns","title":"Building Systems","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"Actors are easily composable into systems. ...","category":"page"},{"location":"patterns/#Fault-tolerant-Systems","page":"Actor Patterns","title":"Fault-tolerant Systems","text":"","category":"section"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"The supervisory tree is not yet implemented.","category":"page"},{"location":"patterns/","page":"Actor Patterns","title":"Actor Patterns","text":"[1]: Paul Butcher, Seven Concurrency Models in Seven Weeks.- 2014, The Pragmatic Programmers, p. 152","category":"page"},{"location":"#YAActL.jl","page":"Home","title":"YAActL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Yet another Actor Library, concurrent programming in Julia with the Actor model.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A quick introduction to YAActL,\nManual, how to:\nunderstand and use actors,\ncontrol actor behavior,\ndo stuff with them.\nActor API: detailed documentation.\nExamples:\na stack,\na recursive factorial,\nInternals\nmessages to actors,\nactor diagnosis","category":"page"},{"location":"#Rationale","page":"Home","title":"Rationale","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Actors are an important concept for concurrent computing.\nThere is no actor library in Julia.\nJulia allows to condense the actor-concept into a  smart and fast library.\nA community effort is needed to do it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you agree with those points, please help with  YAActL's development.","category":"page"},{"location":"#Author(s)","page":"Home","title":"Author(s)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paul Bayer","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"YAActL is licensed under the MIT License.","category":"page"}]
}
